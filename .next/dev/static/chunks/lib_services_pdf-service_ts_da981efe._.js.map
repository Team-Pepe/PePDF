{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/jaena/Downloads/toolsapp/lib/services/pdf-service.ts"],"sourcesContent":["import { PDFDocument, rgb, StandardFonts } from \"pdf-lib\"\r\nimport { Document, Packer, Paragraph, TextRun } from \"docx\"\r\n\r\n// Dynamic import for PDF.js to avoid SSR issues\r\nlet pdfjsLib: any = null\r\n\r\n// Configure PDF.js worker only on client side\r\nif (typeof window !== \"undefined\") {\r\n  import(\"pdfjs-dist\").then((pdfjs) => {\r\n    pdfjsLib = pdfjs\r\n    pdfjsLib.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.js\"\r\n  })\r\n}\r\n\r\nexport interface PDFToWordOptions {\r\n  file: File\r\n  preserveFormatting?: boolean\r\n  includeImages?: boolean\r\n  includeTables?: boolean\r\n}\r\n\r\nexport interface PDFToImagesOptions {\r\n  file: File\r\n  format: \"png\" | \"jpeg\" | \"webp\"\r\n  quality?: number\r\n  scale?: number\r\n}\r\n\r\nexport interface CompressPDFOptions {\r\n  file: File\r\n  quality?: 'low' | 'medium' | 'high'\r\n}\r\n\r\nexport interface EncryptPDFOptions {\r\n  file: File\r\n  password: string\r\n  permissions?: {\r\n    printing?: boolean\r\n    modifying?: boolean\r\n    copying?: boolean\r\n    annotating?: boolean\r\n  }\r\n}\r\n\r\nexport interface MergePDFOptions {\r\n  files: File[]\r\n}\r\n\r\nexport class PDFService {\r\n  /**\r\n   * Extract text from PDF file\r\n   */\r\n  static async extractTextFromPDF(file: File): Promise<string[]> {\r\n    if (typeof window === \"undefined\") {\r\n      throw new Error(\"PDF text extraction is only available on the client side\")\r\n    }\r\n\r\n    if (!pdfjsLib) {\r\n      pdfjsLib = await import(\"pdfjs-dist\")\r\n      pdfjsLib.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.js\"\r\n    }\r\n\r\n    try {\r\n      const arrayBuffer = await file.arrayBuffer()\r\n      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise\r\n      const textPages: string[] = []\r\n\r\n      for (let i = 1; i <= pdf.numPages; i++) {\r\n        const page = await pdf.getPage(i)\r\n        const textContent = await page.getTextContent()\r\n        \r\n        let pageText = \"\"\r\n        textContent.items.forEach((item: any) => {\r\n          if (item.str) {\r\n            pageText += item.str + \" \"\r\n          }\r\n        })\r\n        \r\n        textPages.push(pageText.trim())\r\n      }\r\n\r\n      return textPages\r\n    } catch (error) {\r\n      console.error('Error extracting text from PDF:', error)\r\n      throw new Error('Failed to extract text from PDF')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert PDF to Word document\r\n   */\r\n  static async convertToWord(options: PDFToWordOptions): Promise<Blob> {\r\n    const { file, preserveFormatting = true, includeImages = false, includeTables = false } = options\r\n    \r\n    try {\r\n      // Extract text from PDF\r\n      const textPages = await this.extractTextFromPDF(file)\r\n      \r\n      // Create Word document\r\n      const doc = new Document({\r\n        sections: [{\r\n          properties: {},\r\n          children: [\r\n            new Paragraph({\r\n              children: [\r\n                new TextRun({\r\n                  text: `Converted from: ${file.name}`,\r\n                  bold: true,\r\n                  size: 24,\r\n                }),\r\n              ],\r\n            }),\r\n            new Paragraph({ text: \"\" }), // Empty line\r\n            ...textPages.flatMap((pageText, index) => [\r\n              new Paragraph({\r\n                children: [\r\n                  new TextRun({\r\n                    text: `Page ${index + 1}`,\r\n                    bold: true,\r\n                    size: 20,\r\n                  }),\r\n                ],\r\n              }),\r\n              new Paragraph({ text: \"\" }), // Empty line\r\n              ...this.groupSentencesIntoParagraphs(pageText.split(/[.!?]+/))\r\n                .map(paragraph => new Paragraph({\r\n                  children: [\r\n                    new TextRun({\r\n                      text: paragraph.trim(),\r\n                      size: 20,\r\n                    }),\r\n                  ],\r\n                })),\r\n              new Paragraph({ text: \"\" }), // Empty line between pages\r\n            ])\r\n          ],\r\n        }],\r\n      })\r\n\r\n      // Generate Word document\r\n      const buffer = await Packer.toBuffer(doc)\r\n      return new Blob([new Uint8Array(buffer)], { \r\n        type: \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" \r\n      })\r\n    } catch (error) {\r\n      console.error('Error converting PDF to Word:', error)\r\n      throw new Error('Failed to convert PDF to Word')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert PDF to images\r\n   */\r\n  static async convertToImages(options: PDFToImagesOptions): Promise<Blob[]> {\r\n    if (typeof window === \"undefined\") {\r\n      throw new Error(\"PDF to images conversion is only available on the client side\")\r\n    }\r\n\r\n    if (!pdfjsLib) {\r\n      pdfjsLib = await import(\"pdfjs-dist\")\r\n      pdfjsLib.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.js\"\r\n    }\r\n\r\n    const { file, format, quality = 0.92, scale = 2.0 } = options\r\n    \r\n    try {\r\n      const arrayBuffer = await file.arrayBuffer()\r\n      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise\r\n      const images: Blob[] = []\r\n\r\n      for (let i = 1; i <= pdf.numPages; i++) {\r\n        const page = await pdf.getPage(i)\r\n        const viewport = page.getViewport({ scale })\r\n        \r\n        const canvas = document.createElement('canvas')\r\n        const context = canvas.getContext('2d')!\r\n        canvas.height = viewport.height\r\n        canvas.width = viewport.width\r\n\r\n        await page.render({\r\n          canvasContext: context,\r\n          viewport: viewport\r\n        }).promise\r\n\r\n        const blob = await new Promise<Blob>((resolve) => {\r\n          canvas.toBlob((blob) => {\r\n            resolve(blob!)\r\n          }, `image/${format}`, quality)\r\n        })\r\n\r\n        images.push(blob)\r\n      }\r\n\r\n      return images\r\n    } catch (error) {\r\n      console.error('Error converting PDF to images:', error)\r\n      throw new Error('Failed to convert PDF to images')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compress PDF file\r\n   */\r\n  static async compress(options: CompressPDFOptions): Promise<Blob> {\r\n    const { file, quality = 'medium' } = options\r\n    \r\n    try {\r\n      const arrayBuffer = await file.arrayBuffer()\r\n      const pdfDoc = await PDFDocument.load(arrayBuffer)\r\n\r\n      // Compression settings based on quality\r\n      const compressionOptions = {\r\n        low: { useObjectStreams: false, addDefaultPage: false },\r\n        medium: { useObjectStreams: true, addDefaultPage: false },\r\n        high: { useObjectStreams: true, addDefaultPage: false, compress: true }\r\n      }\r\n\r\n      const pdfBytes = await pdfDoc.save(compressionOptions[quality])\r\n      return new Blob([new Uint8Array(pdfBytes)], { type: \"application/pdf\" })\r\n    } catch (error) {\r\n      console.error('Error compressing PDF:', error)\r\n      throw new Error('Failed to compress PDF')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encrypt PDF file\r\n   */\r\n  static async encrypt(options: EncryptPDFOptions): Promise<Blob> {\r\n    const { file, password, permissions = {} } = options\r\n    \r\n    try {\r\n      const arrayBuffer = await file.arrayBuffer()\r\n      const pdfDoc = await PDFDocument.load(arrayBuffer)\r\n\r\n      // pdf-lib no soporta encriptación directa, por ahora solo guardamos el PDF\r\n      // La encriptación real se debe hacer con otra librería o en el backend\r\n      const pdfBytes = await pdfDoc.save()\r\n\r\n      return new Blob([new Uint8Array(pdfBytes)], { type: \"application/pdf\" })\r\n    } catch (error) {\r\n      console.error('Error encrypting PDF:', error)\r\n      throw new Error('Failed to encrypt PDF')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Merge multiple PDF files\r\n   */\r\n  static async merge(options: MergePDFOptions): Promise<Blob> {\r\n    const { files } = options\r\n    \r\n    try {\r\n      const mergedPdf = await PDFDocument.create()\r\n\r\n      for (const file of files) {\r\n        const arrayBuffer = await file.arrayBuffer()\r\n        const pdf = await PDFDocument.load(arrayBuffer)\r\n        const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices())\r\n        copiedPages.forEach((page) => mergedPdf.addPage(page))\r\n      }\r\n\r\n      const pdfBytes = await mergedPdf.save()\r\n      return new Blob([new Uint8Array(pdfBytes)], { type: \"application/pdf\" })\r\n    } catch (error) {\r\n      console.error('Error merging PDFs:', error)\r\n      throw new Error('Failed to merge PDFs')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Group sentences into paragraphs for better Word formatting\r\n   */\r\n  private static groupSentencesIntoParagraphs(sentences: string[]): string[] {\r\n    const paragraphs: string[] = []\r\n    let currentParagraph = \"\"\r\n    \r\n    sentences.forEach((sentence) => {\r\n      const trimmedSentence = sentence.trim()\r\n      if (trimmedSentence) {\r\n        if (currentParagraph.length + trimmedSentence.length > 500) {\r\n          if (currentParagraph) {\r\n            paragraphs.push(currentParagraph.trim())\r\n          }\r\n          currentParagraph = trimmedSentence + \". \"\r\n        } else {\r\n          currentParagraph += trimmedSentence + \". \"\r\n        }\r\n      }\r\n    })\r\n    \r\n    if (currentParagraph.trim()) {\r\n      paragraphs.push(currentParagraph.trim())\r\n    }\r\n    \r\n    return paragraphs\r\n  }\r\n\r\n  /**\r\n   * Validate if file is a valid PDF\r\n   */\r\n  static async validatePDF(file: File): Promise<boolean> {\r\n    try {\r\n      const arrayBuffer = await file.arrayBuffer()\r\n      await PDFDocument.load(arrayBuffer)\r\n      return true\r\n    } catch {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get PDF metadata\r\n   */\r\n  static async getPDFInfo(file: File): Promise<{\r\n    pageCount: number\r\n    title?: string\r\n    author?: string\r\n    subject?: string\r\n    creator?: string\r\n  }> {\r\n    if (typeof window === \"undefined\") {\r\n      throw new Error(\"PDF info extraction is only available on the client side\")\r\n    }\r\n\r\n    if (!pdfjsLib) {\r\n      pdfjsLib = await import(\"pdfjs-dist\")\r\n      pdfjsLib.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.js\"\r\n    }\r\n\r\n    try {\r\n      const arrayBuffer = await file.arrayBuffer()\r\n      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise\r\n      const metadata = await pdf.getMetadata()\r\n      \r\n      return {\r\n        pageCount: pdf.numPages,\r\n        title: metadata.info?.Title,\r\n        author: metadata.info?.Author,\r\n        subject: metadata.info?.Subject,\r\n        creator: metadata.info?.Creator,\r\n      }\r\n    } catch (error) {\r\n      console.error('Error getting PDF info:', error)\r\n      throw new Error('Failed to get PDF information')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wrap text for better formatting\r\n   */\r\n  private static wrapText(text: string, maxLength: number): string[] {\r\n    const words = text.split(\" \")\r\n    const lines: string[] = []\r\n    let currentLine = \"\"\r\n\r\n    words.forEach((word) => {\r\n      if (currentLine.length + word.length + 1 <= maxLength) {\r\n        currentLine += (currentLine ? \" \" : \"\") + word\r\n      } else {\r\n        if (currentLine) lines.push(currentLine)\r\n        currentLine = word\r\n      }\r\n    })\r\n\r\n    if (currentLine) lines.push(currentLine)\r\n    return lines\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}