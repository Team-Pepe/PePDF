(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/next/dist/compiled/querystring-es3/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function() {
    "use strict";
    var e = {
        815: function(e) {
            function hasOwnProperty(e, r) {
                return Object.prototype.hasOwnProperty.call(e, r);
            }
            e.exports = function(e, n, t, o) {
                n = n || "&";
                t = t || "=";
                var a = {};
                if (typeof e !== "string" || e.length === 0) {
                    return a;
                }
                var i = /\+/g;
                e = e.split(n);
                var u = 1e3;
                if (o && typeof o.maxKeys === "number") {
                    u = o.maxKeys;
                }
                var c = e.length;
                if (u > 0 && c > u) {
                    c = u;
                }
                for(var p = 0; p < c; ++p){
                    var f = e[p].replace(i, "%20"), s = f.indexOf(t), _, l, y, d;
                    if (s >= 0) {
                        _ = f.substr(0, s);
                        l = f.substr(s + 1);
                    } else {
                        _ = f;
                        l = "";
                    }
                    y = decodeURIComponent(_);
                    d = decodeURIComponent(l);
                    if (!hasOwnProperty(a, y)) {
                        a[y] = d;
                    } else if (r(a[y])) {
                        a[y].push(d);
                    } else {
                        a[y] = [
                            a[y],
                            d
                        ];
                    }
                }
                return a;
            };
            var r = Array.isArray || function(e) {
                return Object.prototype.toString.call(e) === "[object Array]";
            };
        },
        577: function(e) {
            var stringifyPrimitive = function(e) {
                switch(typeof e){
                    case "string":
                        return e;
                    case "boolean":
                        return e ? "true" : "false";
                    case "number":
                        return isFinite(e) ? e : "";
                    default:
                        return "";
                }
            };
            e.exports = function(e, t, o, a) {
                t = t || "&";
                o = o || "=";
                if (e === null) {
                    e = undefined;
                }
                if (typeof e === "object") {
                    return map(n(e), function(n) {
                        var a = encodeURIComponent(stringifyPrimitive(n)) + o;
                        if (r(e[n])) {
                            return map(e[n], function(e) {
                                return a + encodeURIComponent(stringifyPrimitive(e));
                            }).join(t);
                        } else {
                            return a + encodeURIComponent(stringifyPrimitive(e[n]));
                        }
                    }).join(t);
                }
                if (!a) return "";
                return encodeURIComponent(stringifyPrimitive(a)) + o + encodeURIComponent(stringifyPrimitive(e));
            };
            var r = Array.isArray || function(e) {
                return Object.prototype.toString.call(e) === "[object Array]";
            };
            function map(e, r) {
                if (e.map) return e.map(r);
                var n = [];
                for(var t = 0; t < e.length; t++){
                    n.push(r(e[t], t));
                }
                return n;
            }
            var n = Object.keys || function(e) {
                var r = [];
                for(var n in e){
                    if (Object.prototype.hasOwnProperty.call(e, n)) r.push(n);
                }
                return r;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(n) {
        var t = r[n];
        if (t !== undefined) {
            return t.exports;
        }
        var o = r[n] = {
            exports: {}
        };
        var a = true;
        try {
            e[n](o, o.exports, __nccwpck_require__);
            a = false;
        } finally{
            if (a) delete r[n];
        }
        return o.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/querystring-es3") + "/";
    var n = {};
    !function() {
        var e = n;
        e.decode = e.parse = __nccwpck_require__(815);
        e.encode = e.stringify = __nccwpck_require__(577);
    }();
    module.exports = n;
})();
}),
"[project]/node_modules/next/dist/compiled/native-url/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function() {
    var e = {
        452: function(e) {
            "use strict";
            e.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/querystring-es3/index.js [app-client] (ecmascript)");
        }
    };
    var t = {};
    function __nccwpck_require__(o) {
        var a = t[o];
        if (a !== undefined) {
            return a.exports;
        }
        var s = t[o] = {
            exports: {}
        };
        var n = true;
        try {
            e[o](s, s.exports, __nccwpck_require__);
            n = false;
        } finally{
            if (n) delete t[o];
        }
        return s.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/native-url") + "/";
    var o = {};
    !function() {
        var e = o;
        var t, a = (t = __nccwpck_require__(452)) && "object" == typeof t && "default" in t ? t.default : t, s = /https?|ftp|gopher|file/;
        function r(e) {
            "string" == typeof e && (e = d(e));
            var t = function(e, t, o) {
                var a = e.auth, s = e.hostname, n = e.protocol || "", p = e.pathname || "", c = e.hash || "", i = e.query || "", u = !1;
                a = a ? encodeURIComponent(a).replace(/%3A/i, ":") + "@" : "", e.host ? u = a + e.host : s && (u = a + (~s.indexOf(":") ? "[" + s + "]" : s), e.port && (u += ":" + e.port)), i && "object" == typeof i && (i = t.encode(i));
                var f = e.search || i && "?" + i || "";
                return n && ":" !== n.substr(-1) && (n += ":"), e.slashes || (!n || o.test(n)) && !1 !== u ? (u = "//" + (u || ""), p && "/" !== p[0] && (p = "/" + p)) : u || (u = ""), c && "#" !== c[0] && (c = "#" + c), f && "?" !== f[0] && (f = "?" + f), {
                    protocol: n,
                    host: u,
                    pathname: p = p.replace(/[?#]/g, encodeURIComponent),
                    search: f = f.replace("#", "%23"),
                    hash: c
                };
            }(e, a, s);
            return "" + t.protocol + t.host + t.pathname + t.search + t.hash;
        }
        var n = "http://", p = "w.w", c = n + p, i = /^([a-z0-9.+-]*:\/\/\/)([a-z0-9.+-]:\/*)?/i, u = /https?|ftp|gopher|file/;
        function h(e, t) {
            var o = "string" == typeof e ? d(e) : e;
            e = "object" == typeof e ? r(e) : e;
            var a = d(t), s = "";
            o.protocol && !o.slashes && (s = o.protocol, e = e.replace(o.protocol, ""), s += "/" === t[0] || "/" === e[0] ? "/" : ""), s && a.protocol && (s = "", a.slashes || (s = a.protocol, t = t.replace(a.protocol, "")));
            var p = e.match(i);
            p && !a.protocol && (e = e.substr((s = p[1] + (p[2] || "")).length), /^\/\/[^/]/.test(t) && (s = s.slice(0, -1)));
            var f = new URL(e, c + "/"), m = new URL(t, f).toString().replace(c, ""), v = a.protocol || o.protocol;
            return v += o.slashes || a.slashes ? "//" : "", !s && v ? m = m.replace(n, v) : s && (m = m.replace(n, "")), u.test(m) || ~t.indexOf(".") || "/" === e.slice(-1) || "/" === t.slice(-1) || "/" !== m.slice(-1) || (m = m.slice(0, -1)), s && (m = s + ("/" === m[0] ? m.substr(1) : m)), m;
        }
        function l() {}
        l.prototype.parse = d, l.prototype.format = r, l.prototype.resolve = h, l.prototype.resolveObject = h;
        var f = /^https?|ftp|gopher|file/, m = /^(.*?)([#?].*)/, v = /^([a-z0-9.+-]*:)(\/{0,3})(.*)/i, _ = /^([a-z0-9.+-]*:)?\/\/\/*/i, b = /^([a-z0-9.+-]*:)(\/{0,2})\[(.*)\]$/i;
        function d(e, t, o) {
            if (void 0 === t && (t = !1), void 0 === o && (o = !1), e && "object" == typeof e && e instanceof l) return e;
            var s = (e = e.trim()).match(m);
            e = s ? s[1].replace(/\\/g, "/") + s[2] : e.replace(/\\/g, "/"), b.test(e) && "/" !== e.slice(-1) && (e += "/");
            var n = !/(^javascript)/.test(e) && e.match(v), i = _.test(e), u = "";
            n && (f.test(n[1]) || (u = n[1].toLowerCase(), e = "" + n[2] + n[3]), n[2] || (i = !1, f.test(n[1]) ? (u = n[1], e = "" + n[3]) : e = "//" + n[3]), 3 !== n[2].length && 1 !== n[2].length || (u = n[1], e = "/" + n[3]));
            var g, y = (s ? s[1] : e).match(/^https?:\/\/[^/]+(:[0-9]+)(?=\/|$)/), w = y && y[1], x = new l, C = "", U = "";
            try {
                g = new URL(e);
            } catch (t) {
                C = t, u || o || !/^\/\//.test(e) || /^\/\/.+[@.]/.test(e) || (U = "/", e = e.substr(1));
                try {
                    g = new URL(e, c);
                } catch (e) {
                    return x.protocol = u, x.href = u, x;
                }
            }
            x.slashes = i && !U, x.host = g.host === p ? "" : g.host, x.hostname = g.hostname === p ? "" : g.hostname.replace(/(\[|\])/g, ""), x.protocol = C ? u || null : g.protocol, x.search = g.search.replace(/\\/g, "%5C"), x.hash = g.hash.replace(/\\/g, "%5C");
            var j = e.split("#");
            !x.search && ~j[0].indexOf("?") && (x.search = "?"), x.hash || "" !== j[1] || (x.hash = "#"), x.query = t ? a.decode(g.search.substr(1)) : x.search.substr(1), x.pathname = U + (n ? function(e) {
                return e.replace(/['^|`]/g, function(e) {
                    return "%" + e.charCodeAt().toString(16).toUpperCase();
                }).replace(/((?:%[0-9A-F]{2})+)/g, function(e, t) {
                    try {
                        return decodeURIComponent(t).split("").map(function(e) {
                            var t = e.charCodeAt();
                            return t > 256 || /^[a-z0-9]$/i.test(e) ? e : "%" + t.toString(16).toUpperCase();
                        }).join("");
                    } catch (e) {
                        return t;
                    }
                });
            }(g.pathname) : g.pathname), "about:" === x.protocol && "blank" === x.pathname && (x.protocol = "", x.pathname = ""), C && "/" !== e[0] && (x.pathname = x.pathname.substr(1)), u && !f.test(u) && "/" !== e.slice(-1) && "/" === x.pathname && (x.pathname = ""), x.path = x.pathname + x.search, x.auth = [
                g.username,
                g.password
            ].map(decodeURIComponent).filter(Boolean).join(":"), x.port = g.port, w && !x.host.endsWith(w) && (x.host += w, x.port = w.slice(1)), x.href = U ? "" + x.pathname + x.search + x.hash : r(x);
            var q = /^(file)/.test(x.href) ? [
                "host",
                "hostname"
            ] : [];
            return Object.keys(x).forEach(function(e) {
                ~q.indexOf(e) || (x[e] = x[e] || null);
            }), x;
        }
        e.parse = d, e.format = r, e.resolve = h, e.resolveObject = function(e, t) {
            return d(h(e, t));
        }, e.Url = l;
    }();
    module.exports = o;
})();
}),
"[project]/node_modules/onnxruntime-common/dist/lib/backend-impl.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "registerBackend",
    ()=>registerBackend,
    "resolveBackend",
    ()=>resolveBackend
]);
const backends = {};
const backendsSortedByPriority = [];
const registerBackend = (name, backend, priority)=>{
    if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {
        const currentBackend = backends[name];
        if (currentBackend === undefined) {
            backends[name] = {
                backend,
                priority
            };
        } else if (currentBackend.priority > priority) {
            // same name is already registered with a higher priority. skip registeration.
            return;
        } else if (currentBackend.priority === priority) {
            if (currentBackend.backend !== backend) {
                throw new Error(`cannot register backend "${name}" using priority ${priority}`);
            }
        }
        if (priority >= 0) {
            const i = backendsSortedByPriority.indexOf(name);
            if (i !== -1) {
                backendsSortedByPriority.splice(i, 1);
            }
            for(let i = 0; i < backendsSortedByPriority.length; i++){
                if (backends[backendsSortedByPriority[i]].priority <= priority) {
                    backendsSortedByPriority.splice(i, 0, name);
                    return;
                }
            }
            backendsSortedByPriority.push(name);
        }
        return;
    }
    throw new TypeError('not a valid backend');
};
const resolveBackend = async (backendHints)=>{
    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
    const errors = [];
    for (const backendName of backendNames){
        const backendInfo = backends[backendName];
        if (backendInfo) {
            if (backendInfo.initialized) {
                return backendInfo.backend;
            } else if (backendInfo.aborted) {
                continue; // current backend is unavailable; try next
            }
            const isInitializing = !!backendInfo.initPromise;
            try {
                if (!isInitializing) {
                    backendInfo.initPromise = backendInfo.backend.init();
                }
                await backendInfo.initPromise;
                backendInfo.initialized = true;
                return backendInfo.backend;
            } catch (e) {
                if (!isInitializing) {
                    errors.push({
                        name: backendName,
                        err: e
                    });
                }
                backendInfo.aborted = true;
            } finally{
                delete backendInfo.initPromise;
            }
        }
    }
    throw new Error(`no available backend found. ERR: ${errors.map((e)=>`[${e.name}] ${e.err}`).join(', ')}`);
}; //# sourceMappingURL=backend-impl.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend-impl.js [app-client] (ecmascript)"); //# sourceMappingURL=backend.js.map
;
}),
"[project]/node_modules/onnxruntime-common/dist/lib/env-impl.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "EnvImpl",
    ()=>EnvImpl
]);
class EnvImpl {
    constructor(){
        this.wasm = {};
        this.webgl = {};
        this.logLevelInternal = 'warning';
    }
    // TODO standadize the getter and setter convention in env for other fields.
    set logLevel(value) {
        if (value === undefined) {
            return;
        }
        if (typeof value !== 'string' || [
            'verbose',
            'info',
            'warning',
            'error',
            'fatal'
        ].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
        }
        this.logLevelInternal = value;
    }
    get logLevel() {
        return this.logLevelInternal;
    }
} //# sourceMappingURL=env-impl.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/lib/env.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "env",
    ()=>env
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$env$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/env-impl.js [app-client] (ecmascript)");
;
const env = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$env$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EnvImpl"](); //# sourceMappingURL=env.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/lib/tensor-impl.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "Tensor",
    ()=>Tensor
]);
const isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';
const isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([
    [
        'float32',
        Float32Array
    ],
    [
        'uint8',
        Uint8Array
    ],
    [
        'int8',
        Int8Array
    ],
    [
        'uint16',
        Uint16Array
    ],
    [
        'int16',
        Int16Array
    ],
    [
        'int32',
        Int32Array
    ],
    [
        'bool',
        Uint8Array
    ],
    [
        'float64',
        Float64Array
    ],
    [
        'uint32',
        Uint32Array
    ]
]);
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([
    [
        Float32Array,
        'float32'
    ],
    [
        Uint8Array,
        'uint8'
    ],
    [
        Int8Array,
        'int8'
    ],
    [
        Uint16Array,
        'uint16'
    ],
    [
        Int16Array,
        'int16'
    ],
    [
        Int32Array,
        'int32'
    ],
    [
        Float64Array,
        'float64'
    ],
    [
        Uint32Array,
        'uint32'
    ]
]);
if (isBigInt64ArrayAvailable) {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');
}
if (isBigUint64ArrayAvailable) {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');
}
/**
 * calculate size from dims.
 *
 * @param dims the dims array. May be an illegal input.
 */ const calculateSize = (dims)=>{
    let size = 1;
    for(let i = 0; i < dims.length; i++){
        const dim = dims[i];
        if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
    }
    return size;
};
class Tensor {
    constructor(arg0, arg1, arg2){
        let type;
        let data;
        let dims;
        // check whether arg0 is type or data
        if (typeof arg0 === 'string') {
            //
            // Override: constructor(type, data, ...)
            //
            type = arg0;
            dims = arg2;
            if (arg0 === 'string') {
                // string tensor
                if (!Array.isArray(arg1)) {
                    throw new TypeError('A string tensor\'s data must be a string array.');
                }
                // we don't check whether every element in the array is string; this is too slow. we assume it's correct and
                // error will be populated at inference
                data = arg1;
            } else {
                // numeric tensor
                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                if (typedArrayConstructor === undefined) {
                    throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                }
                if (Array.isArray(arg1)) {
                    // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces
                    // incorrect results.
                    // 'typedArrayConstructor' should be one of the typed array prototype objects.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data = typedArrayConstructor.from(arg1);
                } else if (arg1 instanceof typedArrayConstructor) {
                    data = arg1;
                } else {
                    throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                }
            }
        } else {
            //
            // Override: constructor(data, ...)
            //
            dims = arg1;
            if (Array.isArray(arg0)) {
                // only boolean[] and string[] is supported
                if (arg0.length === 0) {
                    throw new TypeError('Tensor type cannot be inferred from an empty array.');
                }
                const firstElementType = typeof arg0[0];
                if (firstElementType === 'string') {
                    type = 'string';
                    data = arg0;
                } else if (firstElementType === 'boolean') {
                    type = 'bool';
                    // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is
                    // wrong type. We use 'as any' to make it happy.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data = Uint8Array.from(arg0);
                } else {
                    throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                }
            } else {
                // get tensor type from TypedArray
                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                if (mappedType === undefined) {
                    throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                }
                type = mappedType;
                data = arg0;
            }
        }
        // type and data is processed, now processing dims
        if (dims === undefined) {
            // assume 1-D tensor if dims omitted
            dims = [
                data.length
            ];
        } else if (!Array.isArray(dims)) {
            throw new TypeError('A tensor\'s dims must be a number array');
        }
        // perform check
        const size = calculateSize(dims);
        if (size !== data.length) {
            throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);
        }
        this.dims = dims;
        this.type = type;
        this.data = data;
        this.size = size;
    }
    // #endregion
    /**
     * Create a new tensor object from image object
     *
     * @param buffer - Extracted image buffer data - assuming RGBA format
     * @param imageFormat - input image configuration - required configurations height, width, format
     * @param tensorFormat - output tensor configuration - Default is RGB format
     */ static bufferToTensor(buffer, options) {
        if (buffer === undefined) {
            throw new Error('Image buffer must be defined');
        }
        if (options.height === undefined || options.width === undefined) {
            throw new Error('Image height and width must be defined');
        }
        const { height, width } = options;
        const norm = options.norm;
        let normMean;
        let normBias;
        if (norm === undefined || norm.mean === undefined) {
            normMean = 255;
        } else {
            normMean = norm.mean;
        }
        if (norm === undefined || norm.bias === undefined) {
            normBias = 0;
        } else {
            normBias = norm.bias;
        }
        const inputformat = options.bitmapFormat !== undefined ? options.bitmapFormat : 'RGBA';
        // default value is RGBA since imagedata and HTMLImageElement uses it
        const outputformat = options.tensorFormat !== undefined ? options.tensorFormat !== undefined ? options.tensorFormat : 'RGB' : 'RGB';
        const offset = height * width;
        const float32Data = outputformat === 'RGBA' ? new Float32Array(offset * 4) : new Float32Array(offset * 3);
        // Default pointer assignments
        let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;
        // Updating the pointer assignments based on the input image format
        if (inputformat === 'RGB') {
            step = 3;
            rImagePointer = 0;
            gImagePointer = 1;
            bImagePointer = 2;
            aImagePointer = -1;
        }
        // Updating the pointer assignments based on the output tensor format
        if (outputformat === 'RGBA') {
            aTensorPointer = offset * 3;
        } else if (outputformat === 'RBG') {
            rTensorPointer = 0;
            bTensorPointer = offset;
            gTensorPointer = offset * 2;
        } else if (outputformat === 'BGR') {
            bTensorPointer = 0;
            gTensorPointer = offset;
            rTensorPointer = offset * 2;
        }
        for(let i = 0; i < offset; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step){
            float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias) / normMean;
            float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias) / normMean;
            float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias) / normMean;
            if (aTensorPointer !== -1 && aImagePointer !== -1) {
                float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias) / normMean;
            }
        }
        // Float32Array -> ort.Tensor
        const outputTensor = outputformat === 'RGBA' ? new Tensor('float32', float32Data, [
            1,
            4,
            height,
            width
        ]) : new Tensor('float32', float32Data, [
            1,
            3,
            height,
            width
        ]);
        return outputTensor;
    }
    static async fromImage(image, options) {
        // checking the type of image object
        const isHTMLImageEle = typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement;
        const isImageDataEle = typeof ImageData !== 'undefined' && image instanceof ImageData;
        const isImageBitmap = typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap;
        const isURL = typeof String !== 'undefined' && (image instanceof String || typeof image === 'string');
        let data;
        let tensorConfig = {};
        // filling and checking image configuration options
        if (isHTMLImageEle) {
            // HTMLImageElement - image object - format is RGBA by default
            const canvas = document.createElement('canvas');
            const pixels2DContext = canvas.getContext('2d');
            if (pixels2DContext != null) {
                let height = image.naturalHeight;
                let width = image.naturalWidth;
                if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {
                    height = options.resizedHeight;
                    width = options.resizedWidth;
                }
                if (options !== undefined) {
                    tensorConfig = options;
                    if (options.tensorFormat !== undefined) {
                        throw new Error('Image input config format must be RGBA for HTMLImageElement');
                    } else {
                        tensorConfig.tensorFormat = 'RGBA';
                    }
                    if (options.height !== undefined && options.height !== height) {
                        throw new Error('Image input config height doesn\'t match HTMLImageElement height');
                    } else {
                        tensorConfig.height = height;
                    }
                    if (options.width !== undefined && options.width !== width) {
                        throw new Error('Image input config width doesn\'t match HTMLImageElement width');
                    } else {
                        tensorConfig.width = width;
                    }
                } else {
                    tensorConfig.tensorFormat = 'RGBA';
                    tensorConfig.height = height;
                    tensorConfig.width = width;
                }
                canvas.width = width;
                canvas.height = height;
                pixels2DContext.drawImage(image, 0, 0, width, height);
                data = pixels2DContext.getImageData(0, 0, width, height).data;
            } else {
                throw new Error('Can not access image data');
            }
        } else if (isImageDataEle) {
            // ImageData - image object - format is RGBA by default
            const format = 'RGBA';
            let height;
            let width;
            if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {
                height = options.resizedHeight;
                width = options.resizedWidth;
            } else {
                height = image.height;
                width = image.width;
            }
            if (options !== undefined) {
                tensorConfig = options;
                if (options.bitmapFormat !== undefined && options.bitmapFormat !== format) {
                    throw new Error('Image input config format must be RGBA for ImageData');
                } else {
                    tensorConfig.bitmapFormat = 'RGBA';
                }
            } else {
                tensorConfig.bitmapFormat = 'RGBA';
            }
            tensorConfig.height = height;
            tensorConfig.width = width;
            if (options !== undefined) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const pixels2DContext = tempCanvas.getContext('2d');
                if (pixels2DContext != null) {
                    pixels2DContext.putImageData(image, 0, 0);
                    data = pixels2DContext.getImageData(0, 0, width, height).data;
                } else {
                    throw new Error('Can not access image data');
                }
            } else {
                data = image.data;
            }
        } else if (isImageBitmap) {
            // ImageBitmap - image object - format must be provided by user
            if (options === undefined) {
                throw new Error('Please provide image config with format for Imagebitmap');
            }
            if (options.bitmapFormat !== undefined) {
                throw new Error('Image input config format must be defined for ImageBitmap');
            }
            const pixels2DContext = document.createElement('canvas').getContext('2d');
            if (pixels2DContext != null) {
                const height = image.height;
                const width = image.width;
                pixels2DContext.drawImage(image, 0, 0, width, height);
                data = pixels2DContext.getImageData(0, 0, width, height).data;
                if (options !== undefined) {
                    // using square brackets to avoid TS error - type 'never'
                    if (options.height !== undefined && options.height !== height) {
                        throw new Error('Image input config height doesn\'t match ImageBitmap height');
                    } else {
                        tensorConfig.height = height;
                    }
                    // using square brackets to avoid TS error - type 'never'
                    if (options.width !== undefined && options.width !== width) {
                        throw new Error('Image input config width doesn\'t match ImageBitmap width');
                    } else {
                        tensorConfig.width = width;
                    }
                } else {
                    tensorConfig.height = height;
                    tensorConfig.width = width;
                }
                return Tensor.bufferToTensor(data, tensorConfig);
            } else {
                throw new Error('Can not access image data');
            }
        } else if (isURL) {
            return new Promise((resolve, reject)=>{
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                if (!image || !context) {
                    return reject();
                }
                const newImage = new Image();
                newImage.crossOrigin = 'Anonymous';
                newImage.src = image;
                newImage.onload = ()=>{
                    canvas.width = newImage.width;
                    canvas.height = newImage.height;
                    context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
                    const img = context.getImageData(0, 0, canvas.width, canvas.height);
                    if (options !== undefined) {
                        // using square brackets to avoid TS error - type 'never'
                        if (options.height !== undefined && options.height !== canvas.height) {
                            throw new Error('Image input config height doesn\'t match ImageBitmap height');
                        } else {
                            tensorConfig.height = canvas.height;
                        }
                        // using square brackets to avoid TS error - type 'never'
                        if (options.width !== undefined && options.width !== canvas.width) {
                            throw new Error('Image input config width doesn\'t match ImageBitmap width');
                        } else {
                            tensorConfig.width = canvas.width;
                        }
                    } else {
                        tensorConfig.height = canvas.height;
                        tensorConfig.width = canvas.width;
                    }
                    resolve(Tensor.bufferToTensor(img.data, tensorConfig));
                };
            });
        } else {
            throw new Error('Input data provided is not supported - aborted tensor creation');
        }
        if (data !== undefined) {
            return Tensor.bufferToTensor(data, tensorConfig);
        } else {
            throw new Error('Input data provided is not supported - aborted tensor creation');
        }
    }
    toImageData(options) {
        var _a, _b;
        const pixels2DContext = document.createElement('canvas').getContext('2d');
        let image;
        if (pixels2DContext != null) {
            // Default values for height and width & format
            const width = this.dims[3];
            const height = this.dims[2];
            const channels = this.dims[1];
            const inputformat = options !== undefined ? options.format !== undefined ? options.format : 'RGB' : 'RGB';
            const normMean = options !== undefined ? ((_a = options.norm) === null || _a === void 0 ? void 0 : _a.mean) !== undefined ? options.norm.mean : 255 : 255;
            const normBias = options !== undefined ? ((_b = options.norm) === null || _b === void 0 ? void 0 : _b.bias) !== undefined ? options.norm.bias : 0 : 0;
            const offset = height * width;
            if (options !== undefined) {
                if (options.height !== undefined && options.height !== height) {
                    throw new Error('Image output config height doesn\'t match tensor height');
                }
                if (options.width !== undefined && options.width !== width) {
                    throw new Error('Image output config width doesn\'t match tensor width');
                }
                if (options.format !== undefined && channels === 4 && options.format !== 'RGBA' || channels === 3 && options.format !== 'RGB' && options.format !== 'BGR') {
                    throw new Error('Tensor format doesn\'t match input tensor dims');
                }
            }
            // Default pointer assignments
            const step = 4;
            let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
            let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;
            // Updating the pointer assignments based on the input image format
            if (inputformat === 'RGBA') {
                rTensorPointer = 0;
                gTensorPointer = offset;
                bTensorPointer = offset * 2;
                aTensorPointer = offset * 3;
            } else if (inputformat === 'RGB') {
                rTensorPointer = 0;
                gTensorPointer = offset;
                bTensorPointer = offset * 2;
            } else if (inputformat === 'RBG') {
                rTensorPointer = 0;
                bTensorPointer = offset;
                gTensorPointer = offset * 2;
            }
            image = pixels2DContext.createImageData(width, height);
            for(let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++){
                image.data[rImagePointer] = (this.data[rTensorPointer++] - normBias) * normMean; // R value
                image.data[gImagePointer] = (this.data[gTensorPointer++] - normBias) * normMean; // G value
                image.data[bImagePointer] = (this.data[bTensorPointer++] - normBias) * normMean; // B value
                image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (this.data[aTensorPointer++] - normBias) * normMean; // A value
            }
        } else {
            throw new Error('Can not access image data');
        }
        return image;
    }
    // #endregion
    // #region tensor utilities
    reshape(dims) {
        return new Tensor(this.type, this.data, dims);
    }
} //# sourceMappingURL=tensor-impl.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/lib/tensor.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "Tensor",
    ()=>Tensor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/tensor-impl.js [app-client] (ecmascript)");
;
const Tensor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tensor"]; //# sourceMappingURL=tensor.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/lib/inference-session-impl.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "InferenceSession",
    ()=>InferenceSession
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend-impl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/tensor.js [app-client] (ecmascript)");
;
;
class InferenceSession {
    constructor(handler){
        this.handler = handler;
    }
    async run(feeds, arg1, arg2) {
        const fetches = {};
        let options = {};
        // check inputs
        if (typeof feeds !== 'object' || feeds === null || feeds instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tensor"] || Array.isArray(feeds)) {
            throw new TypeError('\'feeds\' must be an object that use input names as keys and OnnxValue as corresponding values.');
        }
        let isFetchesEmpty = true;
        // determine which override is being used
        if (typeof arg1 === 'object') {
            if (arg1 === null) {
                throw new TypeError('Unexpected argument[1]: cannot be null.');
            }
            if (arg1 instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tensor"]) {
                throw new TypeError('\'fetches\' cannot be a Tensor');
            }
            if (Array.isArray(arg1)) {
                if (arg1.length === 0) {
                    throw new TypeError('\'fetches\' cannot be an empty array.');
                }
                isFetchesEmpty = false;
                // output names
                for (const name of arg1){
                    if (typeof name !== 'string') {
                        throw new TypeError('\'fetches\' must be a string array or an object.');
                    }
                    if (this.outputNames.indexOf(name) === -1) {
                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                    }
                    fetches[name] = null;
                }
                if (typeof arg2 === 'object' && arg2 !== null) {
                    options = arg2;
                } else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'options\' must be an object.');
                }
            } else {
                // decide whether arg1 is fetches or options
                // if any output name is present and its value is valid OnnxValue, we consider it fetches
                let isFetches = false;
                const arg1Keys = Object.getOwnPropertyNames(arg1);
                for (const name of this.outputNames){
                    if (arg1Keys.indexOf(name) !== -1) {
                        const v = arg1[name];
                        if (v === null || v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tensor"]) {
                            isFetches = true;
                            isFetchesEmpty = false;
                            fetches[name] = v;
                        }
                    }
                }
                if (isFetches) {
                    if (typeof arg2 === 'object' && arg2 !== null) {
                        options = arg2;
                    } else if (typeof arg2 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                } else {
                    options = arg1;
                }
            }
        } else if (typeof arg1 !== 'undefined') {
            throw new TypeError('Unexpected argument[1]: must be \'fetches\' or \'options\'.');
        }
        // check if all inputs are in feed
        for (const name of this.inputNames){
            if (typeof feeds[name] === 'undefined') {
                throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
        }
        // if no fetches is specified, we use the full output names list
        if (isFetchesEmpty) {
            for (const name of this.outputNames){
                fetches[name] = null;
            }
        }
        // feeds, fetches and options are prepared
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for(const key in results){
            if (Object.hasOwnProperty.call(results, key)) {
                returnValue[key] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tensor"](results[key].type, results[key].data, results[key].dims);
            }
        }
        return returnValue;
    }
    static async create(arg0, arg1, arg2, arg3) {
        // either load from a file or buffer
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === 'string') {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            } else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
        } else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            } else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            } else if (typeof arg1 === 'number') {
                byteOffset = arg1;
                if (!Number.isSafeInteger(byteOffset)) {
                    throw new RangeError('\'byteOffset\' must be an integer.');
                }
                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
                }
                byteLength = arg0.byteLength - byteOffset;
                if (typeof arg2 === 'number') {
                    byteLength = arg2;
                    if (!Number.isSafeInteger(byteLength)) {
                        throw new RangeError('\'byteLength\' must be an integer.');
                    }
                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                    }
                    if (typeof arg3 === 'object' && arg3 !== null) {
                        options = arg3;
                    } else if (typeof arg3 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                } else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'byteLength\' must be a number.');
                }
            } else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        } else {
            throw new TypeError('Unexpected argument[0]: must be \'path\' or \'buffer\'.');
        }
        // get backend hints
        const eps = options.executionProviders || [];
        const backendHints = eps.map((i)=>typeof i === 'string' ? i : i.name);
        const backend = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveBackend"])(backendHints);
        const handler = await backend.createSessionHandler(filePathOrUint8Array, options);
        return new InferenceSession(handler);
    }
    startProfiling() {
        this.handler.startProfiling();
    }
    endProfiling() {
        this.handler.endProfiling();
    }
    get inputNames() {
        return this.handler.inputNames;
    }
    get outputNames() {
        return this.handler.outputNames;
    }
} //# sourceMappingURL=inference-session-impl.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/lib/inference-session.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "InferenceSession",
    ()=>InferenceSession
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$inference$2d$session$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/inference-session-impl.js [app-client] (ecmascript)");
;
const InferenceSession = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$inference$2d$session$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InferenceSession"]; //# sourceMappingURL=inference-session.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/lib/onnx-value.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([]);
;
 //# sourceMappingURL=onnx-value.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/lib/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * # ONNX Runtime JavaScript API
 *
 * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:
 *
 * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)
 * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)
 * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)
 *
 * See also:
 * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript.html)
 * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)
 *
 * @packageDocumentation
 */ __turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$env$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/env.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$inference$2d$session$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/inference-session.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/tensor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$onnx$2d$value$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/onnx-value.js [app-client] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
;
;
}),
"[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "registerBackend",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["registerBackend"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend-impl.js [app-client] (ecmascript)");
}),
"[project]/node_modules/onnxruntime-common/dist/lib/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InferenceSession",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$inference$2d$session$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InferenceSession"],
    "Tensor",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tensor"],
    "env",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$env$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"],
    "registerBackend",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["registerBackend"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$env$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/env.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$inference$2d$session$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/inference-session.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/tensor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$onnx$2d$value$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/onnx-value.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@huggingface/jinja/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/lexer.ts
__turbopack_context__.s([
    "Environment",
    ()=>Environment,
    "Interpreter",
    ()=>Interpreter,
    "Template",
    ()=>Template,
    "parse",
    ()=>parse,
    "tokenize",
    ()=>tokenize
]);
var TOKEN_TYPES = Object.freeze({
    Text: "Text",
    // The text between Jinja statements or expressions
    NumericLiteral: "NumericLiteral",
    // e.g., 123
    BooleanLiteral: "BooleanLiteral",
    // true or false
    StringLiteral: "StringLiteral",
    // 'string'
    Identifier: "Identifier",
    // Variables, functions, etc.
    Equals: "Equals",
    // =
    OpenParen: "OpenParen",
    // (
    CloseParen: "CloseParen",
    // )
    OpenStatement: "OpenStatement",
    // {%
    CloseStatement: "CloseStatement",
    // %}
    OpenExpression: "OpenExpression",
    // {{
    CloseExpression: "CloseExpression",
    // }}
    OpenSquareBracket: "OpenSquareBracket",
    // [
    CloseSquareBracket: "CloseSquareBracket",
    // ]
    OpenCurlyBracket: "OpenCurlyBracket",
    // {
    CloseCurlyBracket: "CloseCurlyBracket",
    // }
    Comma: "Comma",
    // ,
    Dot: "Dot",
    // .
    Colon: "Colon",
    // :
    Pipe: "Pipe",
    // |
    CallOperator: "CallOperator",
    // ()
    AdditiveBinaryOperator: "AdditiveBinaryOperator",
    // + -
    MultiplicativeBinaryOperator: "MultiplicativeBinaryOperator",
    // * / %
    ComparisonBinaryOperator: "ComparisonBinaryOperator",
    // < > <= >= == !=
    UnaryOperator: "UnaryOperator",
    // ! - +
    // Keywords
    Set: "Set",
    If: "If",
    For: "For",
    In: "In",
    Is: "Is",
    NotIn: "NotIn",
    Else: "Else",
    EndIf: "EndIf",
    ElseIf: "ElseIf",
    EndFor: "EndFor",
    And: "And",
    Or: "Or",
    Not: "UnaryOperator"
});
var KEYWORDS = Object.freeze({
    set: TOKEN_TYPES.Set,
    for: TOKEN_TYPES.For,
    in: TOKEN_TYPES.In,
    is: TOKEN_TYPES.Is,
    if: TOKEN_TYPES.If,
    else: TOKEN_TYPES.Else,
    endif: TOKEN_TYPES.EndIf,
    elif: TOKEN_TYPES.ElseIf,
    endfor: TOKEN_TYPES.EndFor,
    and: TOKEN_TYPES.And,
    or: TOKEN_TYPES.Or,
    not: TOKEN_TYPES.Not,
    "not in": TOKEN_TYPES.NotIn,
    // Literals
    true: TOKEN_TYPES.BooleanLiteral,
    false: TOKEN_TYPES.BooleanLiteral
});
var Token = class {
    /**
   * Constructs a new Token.
   * @param {string} value The raw value as seen inside the source code.
   * @param {TokenType} type The type of token.
   */ constructor(value, type){
        this.value = value;
        this.type = type;
    }
};
function isWord(char) {
    return /\w/.test(char);
}
function isInteger(char) {
    return /[0-9]/.test(char);
}
var ORDERED_MAPPING_TABLE = [
    // Control sequences
    [
        "{%",
        TOKEN_TYPES.OpenStatement
    ],
    [
        "%}",
        TOKEN_TYPES.CloseStatement
    ],
    [
        "{{",
        TOKEN_TYPES.OpenExpression
    ],
    [
        "}}",
        TOKEN_TYPES.CloseExpression
    ],
    // Single character tokens
    [
        "(",
        TOKEN_TYPES.OpenParen
    ],
    [
        ")",
        TOKEN_TYPES.CloseParen
    ],
    [
        "{",
        TOKEN_TYPES.OpenCurlyBracket
    ],
    [
        "}",
        TOKEN_TYPES.CloseCurlyBracket
    ],
    [
        "[",
        TOKEN_TYPES.OpenSquareBracket
    ],
    [
        "]",
        TOKEN_TYPES.CloseSquareBracket
    ],
    [
        ",",
        TOKEN_TYPES.Comma
    ],
    [
        ".",
        TOKEN_TYPES.Dot
    ],
    [
        ":",
        TOKEN_TYPES.Colon
    ],
    [
        "|",
        TOKEN_TYPES.Pipe
    ],
    // Comparison operators
    [
        "<=",
        TOKEN_TYPES.ComparisonBinaryOperator
    ],
    [
        ">=",
        TOKEN_TYPES.ComparisonBinaryOperator
    ],
    [
        "==",
        TOKEN_TYPES.ComparisonBinaryOperator
    ],
    [
        "!=",
        TOKEN_TYPES.ComparisonBinaryOperator
    ],
    [
        "<",
        TOKEN_TYPES.ComparisonBinaryOperator
    ],
    [
        ">",
        TOKEN_TYPES.ComparisonBinaryOperator
    ],
    // Arithmetic operators
    [
        "+",
        TOKEN_TYPES.AdditiveBinaryOperator
    ],
    [
        "-",
        TOKEN_TYPES.AdditiveBinaryOperator
    ],
    [
        "*",
        TOKEN_TYPES.MultiplicativeBinaryOperator
    ],
    [
        "/",
        TOKEN_TYPES.MultiplicativeBinaryOperator
    ],
    [
        "%",
        TOKEN_TYPES.MultiplicativeBinaryOperator
    ],
    // Assignment operator
    [
        "=",
        TOKEN_TYPES.Equals
    ]
];
var ESCAPE_CHARACTERS = /* @__PURE__ */ new Map([
    [
        "n",
        "\n"
    ],
    // New line
    [
        "t",
        "	"
    ],
    // Horizontal tab
    [
        "r",
        "\r"
    ],
    // Carriage return
    [
        "b",
        "\b"
    ],
    // Backspace
    [
        "f",
        "\f"
    ],
    // Form feed
    [
        "v",
        "\v"
    ],
    // Vertical tab
    [
        "'",
        "'"
    ],
    // Single quote
    [
        '"',
        '"'
    ],
    // Double quote
    [
        "\\",
        "\\"
    ]
]);
function preprocess(template, options = {}) {
    if (template.endsWith("\n")) {
        template = template.slice(0, -1);
    }
    template = template.replace(/{#.*?#}/gs, "{##}");
    if (options.lstrip_blocks) {
        template = template.replace(/^[ \t]*({[#%])/gm, "$1");
    }
    if (options.trim_blocks) {
        template = template.replace(/([#%]})\n/g, "$1");
    }
    return template.replace(/{##}/g, "").replace(/-%}\s*/g, "%}").replace(/\s*{%-/g, "{%").replace(/-}}\s*/g, "}}").replace(/\s*{{-/g, "{{");
}
function tokenize(source, options = {}) {
    const tokens = [];
    const src = preprocess(source, options);
    let cursorPosition = 0;
    const consumeWhile = (predicate)=>{
        let str = "";
        while(predicate(src[cursorPosition])){
            if (src[cursorPosition] === "\\") {
                ++cursorPosition;
                if (cursorPosition >= src.length) throw new SyntaxError("Unexpected end of input");
                const escaped = src[cursorPosition++];
                const unescaped = ESCAPE_CHARACTERS.get(escaped);
                if (unescaped === void 0) {
                    throw new SyntaxError(`Unexpected escaped character: ${escaped}`);
                }
                str += unescaped;
                continue;
            }
            str += src[cursorPosition++];
            if (cursorPosition >= src.length) throw new SyntaxError("Unexpected end of input");
        }
        return str;
    };
    main: while(cursorPosition < src.length){
        const lastTokenType = tokens.at(-1)?.type;
        if (lastTokenType === void 0 || lastTokenType === TOKEN_TYPES.CloseStatement || lastTokenType === TOKEN_TYPES.CloseExpression) {
            let text = "";
            while(cursorPosition < src.length && // Keep going until we hit the next Jinja statement or expression
            !(src[cursorPosition] === "{" && (src[cursorPosition + 1] === "%" || src[cursorPosition + 1] === "{"))){
                text += src[cursorPosition++];
            }
            if (text.length > 0) {
                tokens.push(new Token(text, TOKEN_TYPES.Text));
                continue;
            }
        }
        consumeWhile((char2)=>/\s/.test(char2));
        const char = src[cursorPosition];
        if (char === "-" || char === "+") {
            const lastTokenType2 = tokens.at(-1)?.type;
            if (lastTokenType2 === TOKEN_TYPES.Text || lastTokenType2 === void 0) {
                throw new SyntaxError(`Unexpected character: ${char}`);
            }
            switch(lastTokenType2){
                case TOKEN_TYPES.Identifier:
                case TOKEN_TYPES.NumericLiteral:
                case TOKEN_TYPES.BooleanLiteral:
                case TOKEN_TYPES.StringLiteral:
                case TOKEN_TYPES.CloseParen:
                case TOKEN_TYPES.CloseSquareBracket:
                    break;
                default:
                    {
                        ++cursorPosition;
                        const num = consumeWhile(isInteger);
                        tokens.push(new Token(`${char}${num}`, num.length > 0 ? TOKEN_TYPES.NumericLiteral : TOKEN_TYPES.UnaryOperator));
                        continue;
                    }
            }
        }
        for (const [char2, token] of ORDERED_MAPPING_TABLE){
            const slice2 = src.slice(cursorPosition, cursorPosition + char2.length);
            if (slice2 === char2) {
                tokens.push(new Token(char2, token));
                cursorPosition += char2.length;
                continue main;
            }
        }
        if (char === "'" || char === '"') {
            ++cursorPosition;
            const str = consumeWhile((c)=>c !== char);
            tokens.push(new Token(str, TOKEN_TYPES.StringLiteral));
            ++cursorPosition;
            continue;
        }
        if (isInteger(char)) {
            const num = consumeWhile(isInteger);
            tokens.push(new Token(num, TOKEN_TYPES.NumericLiteral));
            continue;
        }
        if (isWord(char)) {
            const word = consumeWhile(isWord);
            const type = Object.hasOwn(KEYWORDS, word) ? KEYWORDS[word] : TOKEN_TYPES.Identifier;
            if (type === TOKEN_TYPES.In && tokens.at(-1)?.type === TOKEN_TYPES.Not) {
                tokens.pop();
                tokens.push(new Token("not in", TOKEN_TYPES.NotIn));
            } else {
                tokens.push(new Token(word, type));
            }
            continue;
        }
        throw new SyntaxError(`Unexpected character: ${char}`);
    }
    return tokens;
}
// src/ast.ts
var Statement = class {
    type = "Statement";
};
var Program = class extends Statement {
    constructor(body){
        super();
        this.body = body;
    }
    type = "Program";
};
var If = class extends Statement {
    constructor(test, body, alternate){
        super();
        this.test = test;
        this.body = body;
        this.alternate = alternate;
    }
    type = "If";
};
var For = class extends Statement {
    constructor(loopvar, iterable, body){
        super();
        this.loopvar = loopvar;
        this.iterable = iterable;
        this.body = body;
    }
    type = "For";
};
var SetStatement = class extends Statement {
    constructor(assignee, value){
        super();
        this.assignee = assignee;
        this.value = value;
    }
    type = "Set";
};
var Expression = class extends Statement {
    type = "Expression";
};
var MemberExpression = class extends Expression {
    constructor(object, property, computed){
        super();
        this.object = object;
        this.property = property;
        this.computed = computed;
    }
    type = "MemberExpression";
};
var CallExpression = class extends Expression {
    constructor(callee, args){
        super();
        this.callee = callee;
        this.args = args;
    }
    type = "CallExpression";
};
var Identifier = class extends Expression {
    /**
   * @param {string} value The name of the identifier
   */ constructor(value){
        super();
        this.value = value;
    }
    type = "Identifier";
};
var Literal = class extends Expression {
    constructor(value){
        super();
        this.value = value;
    }
    type = "Literal";
};
var NumericLiteral = class extends Literal {
    type = "NumericLiteral";
};
var StringLiteral = class extends Literal {
    type = "StringLiteral";
};
var BooleanLiteral = class extends Literal {
    type = "BooleanLiteral";
};
var ArrayLiteral = class extends Literal {
    type = "ArrayLiteral";
};
var TupleLiteral = class extends Literal {
    type = "TupleLiteral";
};
var ObjectLiteral = class extends Literal {
    type = "ObjectLiteral";
};
var BinaryExpression = class extends Expression {
    constructor(operator, left, right){
        super();
        this.operator = operator;
        this.left = left;
        this.right = right;
    }
    type = "BinaryExpression";
};
var FilterExpression = class extends Expression {
    constructor(operand, filter){
        super();
        this.operand = operand;
        this.filter = filter;
    }
    type = "FilterExpression";
};
var TestExpression = class extends Expression {
    constructor(operand, negate, test){
        super();
        this.operand = operand;
        this.negate = negate;
        this.test = test;
    }
    type = "TestExpression";
};
var UnaryExpression = class extends Expression {
    constructor(operator, argument){
        super();
        this.operator = operator;
        this.argument = argument;
    }
    type = "UnaryExpression";
};
var SliceExpression = class extends Expression {
    constructor(start = void 0, stop = void 0, step = void 0){
        super();
        this.start = start;
        this.stop = stop;
        this.step = step;
    }
    type = "SliceExpression";
};
var KeywordArgumentExpression = class extends Expression {
    constructor(key, value){
        super();
        this.key = key;
        this.value = value;
    }
    type = "KeywordArgumentExpression";
};
// src/parser.ts
function parse(tokens) {
    const program = new Program([]);
    let current = 0;
    function expect(type, error) {
        const prev = tokens[current++];
        if (!prev || prev.type !== type) {
            throw new Error(`Parser Error: ${error}. ${prev.type} !== ${type}.`);
        }
        return prev;
    }
    function parseAny() {
        switch(tokens[current].type){
            case TOKEN_TYPES.Text:
                return parseText();
            case TOKEN_TYPES.OpenStatement:
                return parseJinjaStatement();
            case TOKEN_TYPES.OpenExpression:
                return parseJinjaExpression();
            default:
                throw new SyntaxError(`Unexpected token type: ${tokens[current].type}`);
        }
    }
    function not(...types) {
        return current + types.length <= tokens.length && types.some((type, i)=>type !== tokens[current + i].type);
    }
    function is(...types) {
        return current + types.length <= tokens.length && types.every((type, i)=>type === tokens[current + i].type);
    }
    function parseText() {
        return new StringLiteral(expect(TOKEN_TYPES.Text, "Expected text token").value);
    }
    function parseJinjaStatement() {
        expect(TOKEN_TYPES.OpenStatement, "Expected opening statement token");
        let result;
        switch(tokens[current].type){
            case TOKEN_TYPES.Set:
                ++current;
                result = parseSetStatement();
                expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
                break;
            case TOKEN_TYPES.If:
                ++current;
                result = parseIfStatement();
                expect(TOKEN_TYPES.OpenStatement, "Expected {% token");
                expect(TOKEN_TYPES.EndIf, "Expected endif token");
                expect(TOKEN_TYPES.CloseStatement, "Expected %} token");
                break;
            case TOKEN_TYPES.For:
                ++current;
                result = parseForStatement();
                expect(TOKEN_TYPES.OpenStatement, "Expected {% token");
                expect(TOKEN_TYPES.EndFor, "Expected endfor token");
                expect(TOKEN_TYPES.CloseStatement, "Expected %} token");
                break;
            default:
                throw new SyntaxError(`Unknown statement type: ${tokens[current].type}`);
        }
        return result;
    }
    function parseJinjaExpression() {
        expect(TOKEN_TYPES.OpenExpression, "Expected opening expression token");
        const result = parseExpression();
        expect(TOKEN_TYPES.CloseExpression, "Expected closing expression token");
        return result;
    }
    function parseSetStatement() {
        const left = parseExpression();
        if (is(TOKEN_TYPES.Equals)) {
            ++current;
            const value = parseSetStatement();
            return new SetStatement(left, value);
        }
        return left;
    }
    function parseIfStatement() {
        const test = parseExpression();
        expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
        const body = [];
        const alternate = [];
        while(!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && (tokens[current + 1]?.type === TOKEN_TYPES.ElseIf || tokens[current + 1]?.type === TOKEN_TYPES.Else || tokens[current + 1]?.type === TOKEN_TYPES.EndIf))){
            body.push(parseAny());
        }
        if (tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type !== TOKEN_TYPES.EndIf) {
            ++current;
            if (is(TOKEN_TYPES.ElseIf)) {
                expect(TOKEN_TYPES.ElseIf, "Expected elseif token");
                alternate.push(parseIfStatement());
            } else {
                expect(TOKEN_TYPES.Else, "Expected else token");
                expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
                while(!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type === TOKEN_TYPES.EndIf)){
                    alternate.push(parseAny());
                }
            }
        }
        return new If(test, body, alternate);
    }
    function parseExpressionSequence(primary = false) {
        const fn = primary ? parsePrimaryExpression : parseExpression;
        const expressions = [
            fn()
        ];
        const isTuple = is(TOKEN_TYPES.Comma);
        while(isTuple){
            ++current;
            expressions.push(fn());
            if (!is(TOKEN_TYPES.Comma)) {
                break;
            }
        }
        return isTuple ? new TupleLiteral(expressions) : expressions[0];
    }
    function parseForStatement() {
        const loopVariable = parseExpressionSequence(true);
        if (!(loopVariable instanceof Identifier || loopVariable instanceof TupleLiteral)) {
            throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${loopVariable.type} instead`);
        }
        expect(TOKEN_TYPES.In, "Expected `in` keyword following loop variable");
        const iterable = parseExpression();
        expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
        const body = [];
        while(not(TOKEN_TYPES.OpenStatement, TOKEN_TYPES.EndFor)){
            body.push(parseAny());
        }
        return new For(loopVariable, iterable, body);
    }
    function parseExpression() {
        return parseTernaryExpression();
    }
    function parseTernaryExpression() {
        const a = parseLogicalOrExpression();
        if (is(TOKEN_TYPES.If)) {
            ++current;
            const predicate = parseLogicalOrExpression();
            expect(TOKEN_TYPES.Else, "Expected else token");
            const b = parseLogicalOrExpression();
            return new If(predicate, [
                a
            ], [
                b
            ]);
        }
        return a;
    }
    function parseLogicalOrExpression() {
        let left = parseLogicalAndExpression();
        while(is(TOKEN_TYPES.Or)){
            const operator = tokens[current];
            ++current;
            const right = parseLogicalAndExpression();
            left = new BinaryExpression(operator, left, right);
        }
        return left;
    }
    function parseLogicalAndExpression() {
        let left = parseLogicalNegationExpression();
        while(is(TOKEN_TYPES.And)){
            const operator = tokens[current];
            ++current;
            const right = parseLogicalNegationExpression();
            left = new BinaryExpression(operator, left, right);
        }
        return left;
    }
    function parseLogicalNegationExpression() {
        let right;
        while(is(TOKEN_TYPES.Not)){
            const operator = tokens[current];
            ++current;
            const arg = parseLogicalNegationExpression();
            right = new UnaryExpression(operator, arg);
        }
        return right ?? parseComparisonExpression();
    }
    function parseComparisonExpression() {
        let left = parseAdditiveExpression();
        while(is(TOKEN_TYPES.ComparisonBinaryOperator) || is(TOKEN_TYPES.In) || is(TOKEN_TYPES.NotIn)){
            const operator = tokens[current];
            ++current;
            const right = parseAdditiveExpression();
            left = new BinaryExpression(operator, left, right);
        }
        return left;
    }
    function parseAdditiveExpression() {
        let left = parseMultiplicativeExpression();
        while(is(TOKEN_TYPES.AdditiveBinaryOperator)){
            const operator = tokens[current];
            ++current;
            const right = parseMultiplicativeExpression();
            left = new BinaryExpression(operator, left, right);
        }
        return left;
    }
    function parseCallMemberExpression() {
        const member = parseMemberExpression();
        if (is(TOKEN_TYPES.OpenParen)) {
            return parseCallExpression(member);
        }
        return member;
    }
    function parseCallExpression(callee) {
        let callExpression = new CallExpression(callee, parseArgs());
        if (is(TOKEN_TYPES.OpenParen)) {
            callExpression = parseCallExpression(callExpression);
        }
        return callExpression;
    }
    function parseArgs() {
        expect(TOKEN_TYPES.OpenParen, "Expected opening parenthesis for arguments list");
        const args = parseArgumentsList();
        expect(TOKEN_TYPES.CloseParen, "Expected closing parenthesis for arguments list");
        return args;
    }
    function parseArgumentsList() {
        const args = [];
        while(!is(TOKEN_TYPES.CloseParen)){
            let argument = parseExpression();
            if (is(TOKEN_TYPES.Equals)) {
                ++current;
                if (!(argument instanceof Identifier)) {
                    throw new SyntaxError(`Expected identifier for keyword argument`);
                }
                const value = parseExpression();
                argument = new KeywordArgumentExpression(argument, value);
            }
            args.push(argument);
            if (is(TOKEN_TYPES.Comma)) {
                ++current;
            }
        }
        return args;
    }
    function parseMemberExpressionArgumentsList() {
        const slices = [];
        let isSlice = false;
        while(!is(TOKEN_TYPES.CloseSquareBracket)){
            if (is(TOKEN_TYPES.Colon)) {
                slices.push(void 0);
                ++current;
                isSlice = true;
            } else {
                slices.push(parseExpression());
                if (is(TOKEN_TYPES.Colon)) {
                    ++current;
                    isSlice = true;
                }
            }
        }
        if (slices.length === 0) {
            throw new SyntaxError(`Expected at least one argument for member/slice expression`);
        }
        if (isSlice) {
            if (slices.length > 3) {
                throw new SyntaxError(`Expected 0-3 arguments for slice expression`);
            }
            return new SliceExpression(...slices);
        }
        return slices[0];
    }
    function parseMemberExpression() {
        let object = parsePrimaryExpression();
        while(is(TOKEN_TYPES.Dot) || is(TOKEN_TYPES.OpenSquareBracket)){
            const operator = tokens[current];
            ++current;
            let property;
            const computed = operator.type !== TOKEN_TYPES.Dot;
            if (computed) {
                property = parseMemberExpressionArgumentsList();
                expect(TOKEN_TYPES.CloseSquareBracket, "Expected closing square bracket");
            } else {
                property = parsePrimaryExpression();
                if (property.type !== "Identifier") {
                    throw new SyntaxError(`Expected identifier following dot operator`);
                }
            }
            object = new MemberExpression(object, property, computed);
        }
        return object;
    }
    function parseMultiplicativeExpression() {
        let left = parseTestExpression();
        while(is(TOKEN_TYPES.MultiplicativeBinaryOperator)){
            const operator = tokens[current];
            ++current;
            const right = parseTestExpression();
            left = new BinaryExpression(operator, left, right);
        }
        return left;
    }
    function parseTestExpression() {
        let operand = parseFilterExpression();
        while(is(TOKEN_TYPES.Is)){
            ++current;
            const negate = is(TOKEN_TYPES.Not);
            if (negate) {
                ++current;
            }
            let filter = parsePrimaryExpression();
            if (filter instanceof BooleanLiteral) {
                filter = new Identifier(filter.value.toString());
            }
            if (!(filter instanceof Identifier)) {
                throw new SyntaxError(`Expected identifier for the test`);
            }
            operand = new TestExpression(operand, negate, filter);
        }
        return operand;
    }
    function parseFilterExpression() {
        let operand = parseCallMemberExpression();
        while(is(TOKEN_TYPES.Pipe)){
            ++current;
            let filter = parsePrimaryExpression();
            if (!(filter instanceof Identifier)) {
                throw new SyntaxError(`Expected identifier for the filter`);
            }
            if (is(TOKEN_TYPES.OpenParen)) {
                filter = parseCallExpression(filter);
            }
            operand = new FilterExpression(operand, filter);
        }
        return operand;
    }
    function parsePrimaryExpression() {
        const token = tokens[current];
        switch(token.type){
            case TOKEN_TYPES.NumericLiteral:
                ++current;
                return new NumericLiteral(Number(token.value));
            case TOKEN_TYPES.StringLiteral:
                ++current;
                return new StringLiteral(token.value);
            case TOKEN_TYPES.BooleanLiteral:
                ++current;
                return new BooleanLiteral(token.value === "true");
            case TOKEN_TYPES.Identifier:
                ++current;
                return new Identifier(token.value);
            case TOKEN_TYPES.OpenParen:
                {
                    ++current;
                    const expression = parseExpressionSequence();
                    if (tokens[current].type !== TOKEN_TYPES.CloseParen) {
                        throw new SyntaxError(`Expected closing parenthesis, got ${tokens[current].type} instead`);
                    }
                    ++current;
                    return expression;
                }
            case TOKEN_TYPES.OpenSquareBracket:
                {
                    ++current;
                    const values = [];
                    while(!is(TOKEN_TYPES.CloseSquareBracket)){
                        values.push(parseExpression());
                        if (is(TOKEN_TYPES.Comma)) {
                            ++current;
                        }
                    }
                    ++current;
                    return new ArrayLiteral(values);
                }
            case TOKEN_TYPES.OpenCurlyBracket:
                {
                    ++current;
                    const values = /* @__PURE__ */ new Map();
                    while(!is(TOKEN_TYPES.CloseCurlyBracket)){
                        const key = parseExpression();
                        expect(TOKEN_TYPES.Colon, "Expected colon between key and value in object literal");
                        const value = parseExpression();
                        values.set(key, value);
                        if (is(TOKEN_TYPES.Comma)) {
                            ++current;
                        }
                    }
                    ++current;
                    return new ObjectLiteral(values);
                }
            default:
                throw new SyntaxError(`Unexpected token: ${token.type}`);
        }
    }
    while(current < tokens.length){
        program.body.push(parseAny());
    }
    return program;
}
// src/utils.ts
function range(start, stop, step = 1) {
    if (stop === void 0) {
        stop = start;
        start = 0;
    }
    const result = [];
    for(let i = start; i < stop; i += step){
        result.push(i);
    }
    return result;
}
function slice(array, start, stop, step = 1) {
    const direction = Math.sign(step);
    if (direction >= 0) {
        start = (start ??= 0) < 0 ? Math.max(array.length + start, 0) : Math.min(start, array.length);
        stop = (stop ??= array.length) < 0 ? Math.max(array.length + stop, 0) : Math.min(stop, array.length);
    } else {
        start = (start ??= array.length - 1) < 0 ? Math.max(array.length + start, -1) : Math.min(start, array.length - 1);
        stop = (stop ??= -1) < -1 ? Math.max(array.length + stop, -1) : Math.min(stop, array.length - 1);
    }
    const result = [];
    for(let i = start; direction * i < direction * stop; i += step){
        result.push(array[i]);
    }
    return result;
}
function titleCase(value) {
    return value.replace(/\b\w/g, (c)=>c.toUpperCase());
}
// src/runtime.ts
var RuntimeValue = class {
    type = "RuntimeValue";
    value;
    /**
   * A collection of built-in functions for this type.
   */ builtins = /* @__PURE__ */ new Map();
    /**
   * Creates a new RuntimeValue.
   */ constructor(value = void 0){
        this.value = value;
    }
    /**
   * Determines truthiness or falsiness of the runtime value.
   * This function should be overridden by subclasses if it has custom truthiness criteria.
   * @returns {BooleanValue} BooleanValue(true) if the value is truthy, BooleanValue(false) otherwise.
   */ __bool__() {
        return new BooleanValue(!!this.value);
    }
};
var NumericValue = class extends RuntimeValue {
    type = "NumericValue";
};
var StringValue = class extends RuntimeValue {
    type = "StringValue";
    builtins = /* @__PURE__ */ new Map([
        [
            "upper",
            new FunctionValue(()=>{
                return new StringValue(this.value.toUpperCase());
            })
        ],
        [
            "lower",
            new FunctionValue(()=>{
                return new StringValue(this.value.toLowerCase());
            })
        ],
        [
            "strip",
            new FunctionValue(()=>{
                return new StringValue(this.value.trim());
            })
        ],
        [
            "title",
            new FunctionValue(()=>{
                return new StringValue(titleCase(this.value));
            })
        ],
        [
            "length",
            new NumericValue(this.value.length)
        ]
    ]);
};
var BooleanValue = class extends RuntimeValue {
    type = "BooleanValue";
};
var ObjectValue = class extends RuntimeValue {
    type = "ObjectValue";
    /**
   * NOTE: necessary to override since all JavaScript arrays are considered truthy,
   * while only non-empty Python arrays are consider truthy.
   *
   * e.g.,
   *  - JavaScript:  {} && 5 -> 5
   *  - Python:      {} and 5 -> {}
   */ __bool__() {
        return new BooleanValue(this.value.size > 0);
    }
    builtins = /* @__PURE__ */ new Map([
        [
            "get",
            new FunctionValue(([key, defaultValue])=>{
                if (!(key instanceof StringValue)) {
                    throw new Error(`Object key must be a string: got ${key.type}`);
                }
                return this.value.get(key.value) ?? defaultValue ?? new NullValue();
            })
        ],
        [
            "items",
            new FunctionValue(()=>{
                return new ArrayValue(Array.from(this.value.entries()).map(([key, value])=>new ArrayValue([
                        new StringValue(key),
                        value
                    ])));
            })
        ]
    ]);
};
var ArrayValue = class extends RuntimeValue {
    type = "ArrayValue";
    builtins = /* @__PURE__ */ new Map([
        [
            "length",
            new NumericValue(this.value.length)
        ]
    ]);
    /**
   * NOTE: necessary to override since all JavaScript arrays are considered truthy,
   * while only non-empty Python arrays are consider truthy.
   *
   * e.g.,
   *  - JavaScript:  [] && 5 -> 5
   *  - Python:      [] and 5 -> []
   */ __bool__() {
        return new BooleanValue(this.value.length > 0);
    }
};
var TupleValue = class extends ArrayValue {
    type = "TupleValue";
};
var FunctionValue = class extends RuntimeValue {
    type = "FunctionValue";
};
var NullValue = class extends RuntimeValue {
    type = "NullValue";
};
var UndefinedValue = class extends RuntimeValue {
    type = "UndefinedValue";
};
var Environment = class {
    constructor(parent){
        this.parent = parent;
    }
    /**
   * The variables declared in this environment.
   */ variables = /* @__PURE__ */ new Map([
        [
            "namespace",
            new FunctionValue((args)=>{
                if (args.length === 0) {
                    return new ObjectValue(/* @__PURE__ */ new Map());
                }
                if (args.length !== 1 || !(args[0] instanceof ObjectValue)) {
                    throw new Error("`namespace` expects either zero arguments or a single object argument");
                }
                return args[0];
            })
        ]
    ]);
    /**
   * The tests available in this environment.
   */ tests = /* @__PURE__ */ new Map([
        [
            "boolean",
            (operand)=>operand.type === "BooleanValue"
        ],
        [
            "callable",
            (operand)=>operand instanceof FunctionValue
        ],
        [
            "odd",
            (operand)=>{
                if (operand.type !== "NumericValue") {
                    throw new Error(`Cannot apply test "odd" to type: ${operand.type}`);
                }
                return operand.value % 2 !== 0;
            }
        ],
        [
            "even",
            (operand)=>{
                if (operand.type !== "NumericValue") {
                    throw new Error(`Cannot apply test "even" to type: ${operand.type}`);
                }
                return operand.value % 2 === 0;
            }
        ],
        [
            "false",
            (operand)=>operand.type === "BooleanValue" && !operand.value
        ],
        [
            "true",
            (operand)=>operand.type === "BooleanValue" && operand.value
        ],
        [
            "number",
            (operand)=>operand.type === "NumericValue"
        ],
        [
            "integer",
            (operand)=>operand.type === "NumericValue" && Number.isInteger(operand.value)
        ],
        [
            "iterable",
            (operand)=>operand instanceof ArrayValue || operand instanceof StringValue
        ],
        [
            "lower",
            (operand)=>{
                const str = operand.value;
                return operand.type === "StringValue" && str === str.toLowerCase();
            }
        ],
        [
            "upper",
            (operand)=>{
                const str = operand.value;
                return operand.type === "StringValue" && str === str.toUpperCase();
            }
        ],
        [
            "none",
            (operand)=>operand.type === "NullValue"
        ],
        [
            "defined",
            (operand)=>operand.type !== "UndefinedValue"
        ],
        [
            "undefined",
            (operand)=>operand.type === "UndefinedValue"
        ],
        [
            "equalto",
            (a, b)=>a.value === b.value
        ]
    ]);
    /**
   * Set the value of a variable in the current environment.
   */ set(name, value) {
        return this.declareVariable(name, convertToRuntimeValues(value));
    }
    declareVariable(name, value) {
        if (this.variables.has(name)) {
            throw new SyntaxError(`Variable already declared: ${name}`);
        }
        this.variables.set(name, value);
        return value;
    }
    // private assignVariable(name: string, value: AnyRuntimeValue): AnyRuntimeValue {
    // 	const env = this.resolve(name);
    // 	env.variables.set(name, value);
    // 	return value;
    // }
    /**
   * Set variable in the current scope.
   * See https://jinja.palletsprojects.com/en/3.0.x/templates/#assignments for more information.
   */ setVariable(name, value) {
        this.variables.set(name, value);
        return value;
    }
    /**
   * Resolve the environment in which the variable is declared.
   * @param {string} name The name of the variable.
   * @returns {Environment} The environment in which the variable is declared.
   */ resolve(name) {
        if (this.variables.has(name)) {
            return this;
        }
        if (this.parent) {
            return this.parent.resolve(name);
        }
        throw new Error(`Unknown variable: ${name}`);
    }
    lookupVariable(name) {
        try {
            return this.resolve(name).variables.get(name) ?? new UndefinedValue();
        } catch  {
            return new UndefinedValue();
        }
    }
};
var Interpreter = class {
    global;
    constructor(env){
        this.global = env ?? new Environment();
    }
    /**
   * Run the program.
   */ run(program) {
        return this.evaluate(program, this.global);
    }
    /**
   * Evaluates expressions following the binary operation type.
   */ evaluateBinaryExpression(node, environment) {
        const left = this.evaluate(node.left, environment);
        switch(node.operator.value){
            case "and":
                return left.__bool__().value ? this.evaluate(node.right, environment) : left;
            case "or":
                return left.__bool__().value ? left : this.evaluate(node.right, environment);
        }
        const right = this.evaluate(node.right, environment);
        switch(node.operator.value){
            case "==":
                return new BooleanValue(left.value == right.value);
            case "!=":
                return new BooleanValue(left.value != right.value);
        }
        if (left instanceof UndefinedValue || right instanceof UndefinedValue) {
            throw new Error("Cannot perform operation on undefined values");
        } else if (left instanceof NullValue || right instanceof NullValue) {
            throw new Error("Cannot perform operation on null values");
        } else if (left instanceof NumericValue && right instanceof NumericValue) {
            switch(node.operator.value){
                case "+":
                    return new NumericValue(left.value + right.value);
                case "-":
                    return new NumericValue(left.value - right.value);
                case "*":
                    return new NumericValue(left.value * right.value);
                case "/":
                    return new NumericValue(left.value / right.value);
                case "%":
                    return new NumericValue(left.value % right.value);
                case "<":
                    return new BooleanValue(left.value < right.value);
                case ">":
                    return new BooleanValue(left.value > right.value);
                case ">=":
                    return new BooleanValue(left.value >= right.value);
                case "<=":
                    return new BooleanValue(left.value <= right.value);
            }
        } else if (left instanceof ArrayValue && right instanceof ArrayValue) {
            switch(node.operator.value){
                case "+":
                    return new ArrayValue(left.value.concat(right.value));
            }
        } else if (right instanceof ArrayValue) {
            const member = right.value.find((x)=>x.value === left.value) !== void 0;
            switch(node.operator.value){
                case "in":
                    return new BooleanValue(member);
                case "not in":
                    return new BooleanValue(!member);
            }
        }
        if (left instanceof StringValue || right instanceof StringValue) {
            switch(node.operator.value){
                case "+":
                    return new StringValue(left.value.toString() + right.value.toString());
            }
        }
        if (left instanceof StringValue && right instanceof StringValue) {
            switch(node.operator.value){
                case "in":
                    return new BooleanValue(right.value.includes(left.value));
                case "not in":
                    return new BooleanValue(!right.value.includes(left.value));
            }
        }
        if (left instanceof StringValue && right instanceof ObjectValue) {
            switch(node.operator.value){
                case "in":
                    return new BooleanValue(right.value.has(left.value));
                case "not in":
                    return new BooleanValue(!right.value.has(left.value));
            }
        }
        throw new SyntaxError(`Unknown operator "${node.operator.value}" between ${left.type} and ${right.type}`);
    }
    /**
   * Evaluates expressions following the filter operation type.
   */ evaluateFilterExpression(node, environment) {
        const operand = this.evaluate(node.operand, environment);
        if (node.filter.type === "Identifier") {
            const filter = node.filter;
            if (operand instanceof ArrayValue) {
                switch(filter.value){
                    case "list":
                        return operand;
                    case "first":
                        return operand.value[0];
                    case "last":
                        return operand.value[operand.value.length - 1];
                    case "length":
                        return new NumericValue(operand.value.length);
                    case "reverse":
                        return new ArrayValue(operand.value.reverse());
                    case "sort":
                        return new ArrayValue(operand.value.sort((a, b)=>{
                            if (a.type !== b.type) {
                                throw new Error(`Cannot compare different types: ${a.type} and ${b.type}`);
                            }
                            switch(a.type){
                                case "NumericValue":
                                    return a.value - b.value;
                                case "StringValue":
                                    return a.value.localeCompare(b.value);
                                default:
                                    throw new Error(`Cannot compare type: ${a.type}`);
                            }
                        }));
                    default:
                        throw new Error(`Unknown ArrayValue filter: ${filter.value}`);
                }
            } else if (operand instanceof StringValue) {
                switch(filter.value){
                    case "length":
                        return new NumericValue(operand.value.length);
                    case "upper":
                        return new StringValue(operand.value.toUpperCase());
                    case "lower":
                        return new StringValue(operand.value.toLowerCase());
                    case "title":
                        return new StringValue(titleCase(operand.value));
                    case "capitalize":
                        return new StringValue(operand.value.charAt(0).toUpperCase() + operand.value.slice(1));
                    case "trim":
                        return new StringValue(operand.value.trim());
                    default:
                        throw new Error(`Unknown StringValue filter: ${filter.value}`);
                }
            } else if (operand instanceof NumericValue) {
                switch(filter.value){
                    case "abs":
                        return new NumericValue(Math.abs(operand.value));
                    default:
                        throw new Error(`Unknown NumericValue filter: ${filter.value}`);
                }
            } else if (operand instanceof ObjectValue) {
                switch(filter.value){
                    case "items":
                        return new ArrayValue(Array.from(operand.value.entries()).map(([key, value])=>new ArrayValue([
                                new StringValue(key),
                                value
                            ])));
                    case "length":
                        return new NumericValue(operand.value.size);
                    default:
                        throw new Error(`Unknown ObjectValue filter: ${filter.value}`);
                }
            }
            throw new Error(`Cannot apply filter "${filter.value}" to type: ${operand.type}`);
        } else if (node.filter.type === "CallExpression") {
            const filter = node.filter;
            if (filter.callee.type !== "Identifier") {
                throw new Error(`Unknown filter: ${filter.callee.type}`);
            }
            const filterName = filter.callee.value;
            if (operand instanceof ArrayValue) {
                switch(filterName){
                    case "selectattr":
                        {
                            if (operand.value.some((x)=>!(x instanceof ObjectValue))) {
                                throw new Error("`selectattr` can only be applied to array of objects");
                            }
                            if (filter.args.some((x)=>x.type !== "StringLiteral")) {
                                throw new Error("arguments of `selectattr` must be strings");
                            }
                            const [attr, testName, value] = filter.args.map((x)=>this.evaluate(x, environment));
                            let testFunction;
                            if (testName) {
                                const test = environment.tests.get(testName.value);
                                if (!test) {
                                    throw new Error(`Unknown test: ${testName.value}`);
                                }
                                testFunction = test;
                            } else {
                                testFunction = (...x)=>x[0].__bool__().value;
                            }
                            const filtered = operand.value.filter((item)=>{
                                const a = item.value.get(attr.value);
                                if (a) {
                                    return testFunction(a, value);
                                }
                                return false;
                            });
                            return new ArrayValue(filtered);
                        }
                }
                throw new Error(`Unknown ArrayValue filter: ${filterName}`);
            } else {
                throw new Error(`Cannot apply filter "${filterName}" to type: ${operand.type}`);
            }
        }
        throw new Error(`Unknown filter: ${node.filter.type}`);
    }
    /**
   * Evaluates expressions following the test operation type.
   */ evaluateTestExpression(node, environment) {
        const operand = this.evaluate(node.operand, environment);
        const test = environment.tests.get(node.test.value);
        if (!test) {
            throw new Error(`Unknown test: ${node.test.value}`);
        }
        const result = test(operand);
        return new BooleanValue(node.negate ? !result : result);
    }
    /**
   * Evaluates expressions following the unary operation type.
   */ evaluateUnaryExpression(node, environment) {
        const argument = this.evaluate(node.argument, environment);
        switch(node.operator.value){
            case "not":
                return new BooleanValue(!argument.value);
            default:
                throw new SyntaxError(`Unknown operator: ${node.operator.value}`);
        }
    }
    evalProgram(program, environment) {
        return this.evaluateBlock(program.body, environment);
    }
    evaluateBlock(statements, environment) {
        let result = "";
        for (const statement of statements){
            const lastEvaluated = this.evaluate(statement, environment);
            if (lastEvaluated.type !== "NullValue" && lastEvaluated.type !== "UndefinedValue") {
                result += lastEvaluated.value;
            }
        }
        return new StringValue(result);
    }
    evaluateIdentifier(node, environment) {
        return environment.lookupVariable(node.value);
    }
    evaluateCallExpression(expr, environment) {
        const args = [];
        const kwargs = /* @__PURE__ */ new Map();
        for (const argument of expr.args){
            if (argument.type === "KeywordArgumentExpression") {
                const kwarg = argument;
                kwargs.set(kwarg.key.value, this.evaluate(kwarg.value, environment));
            } else {
                args.push(this.evaluate(argument, environment));
            }
        }
        if (kwargs.size > 0) {
            args.push(new ObjectValue(kwargs));
        }
        const fn = this.evaluate(expr.callee, environment);
        if (fn.type !== "FunctionValue") {
            throw new Error(`Cannot call something that is not a function: got ${fn.type}`);
        }
        return fn.value(args, environment);
    }
    evaluateSliceExpression(object, expr, environment) {
        if (!(object instanceof ArrayValue || object instanceof StringValue)) {
            throw new Error("Slice object must be an array or string");
        }
        const start = this.evaluate(expr.start, environment);
        const stop = this.evaluate(expr.stop, environment);
        const step = this.evaluate(expr.step, environment);
        if (!(start instanceof NumericValue || start instanceof UndefinedValue)) {
            throw new Error("Slice start must be numeric or undefined");
        }
        if (!(stop instanceof NumericValue || stop instanceof UndefinedValue)) {
            throw new Error("Slice stop must be numeric or undefined");
        }
        if (!(step instanceof NumericValue || step instanceof UndefinedValue)) {
            throw new Error("Slice step must be numeric or undefined");
        }
        if (object instanceof ArrayValue) {
            return new ArrayValue(slice(object.value, start.value, stop.value, step.value));
        } else {
            return new StringValue(slice(Array.from(object.value), start.value, stop.value, step.value).join(""));
        }
    }
    evaluateMemberExpression(expr, environment) {
        const object = this.evaluate(expr.object, environment);
        let property;
        if (expr.computed) {
            if (expr.property.type === "SliceExpression") {
                return this.evaluateSliceExpression(object, expr.property, environment);
            } else {
                property = this.evaluate(expr.property, environment);
            }
        } else {
            property = new StringValue(expr.property.value);
        }
        let value;
        if (object instanceof ObjectValue) {
            if (!(property instanceof StringValue)) {
                throw new Error(`Cannot access property with non-string: got ${property.type}`);
            }
            value = object.value.get(property.value) ?? object.builtins.get(property.value);
        } else if (object instanceof ArrayValue || object instanceof StringValue) {
            if (property instanceof NumericValue) {
                value = object.value.at(property.value);
                if (object instanceof StringValue) {
                    value = new StringValue(object.value.at(property.value));
                }
            } else if (property instanceof StringValue) {
                value = object.builtins.get(property.value);
            } else {
                throw new Error(`Cannot access property with non-string/non-number: got ${property.type}`);
            }
        } else {
            if (!(property instanceof StringValue)) {
                throw new Error(`Cannot access property with non-string: got ${property.type}`);
            }
            value = object.builtins.get(property.value);
        }
        return value instanceof RuntimeValue ? value : new UndefinedValue();
    }
    evaluateSet(node, environment) {
        const rhs = this.evaluate(node.value, environment);
        if (node.assignee.type === "Identifier") {
            const variableName = node.assignee.value;
            environment.setVariable(variableName, rhs);
        } else if (node.assignee.type === "MemberExpression") {
            const member = node.assignee;
            const object = this.evaluate(member.object, environment);
            if (!(object instanceof ObjectValue)) {
                throw new Error("Cannot assign to member of non-object");
            }
            if (member.property.type !== "Identifier") {
                throw new Error("Cannot assign to member with non-identifier property");
            }
            object.value.set(member.property.value, rhs);
        } else {
            throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(node.assignee)}`);
        }
        return new NullValue();
    }
    evaluateIf(node, environment) {
        const test = this.evaluate(node.test, environment);
        return this.evaluateBlock(test.__bool__().value ? node.body : node.alternate, environment);
    }
    evaluateFor(node, environment) {
        const scope = new Environment(environment);
        const iterable = this.evaluate(node.iterable, scope);
        if (!(iterable instanceof ArrayValue)) {
            throw new Error(`Expected iterable type in for loop: got ${iterable.type}`);
        }
        let result = "";
        for(let i = 0; i < iterable.value.length; ++i){
            const loop = /* @__PURE__ */ new Map([
                [
                    "index",
                    new NumericValue(i + 1)
                ],
                [
                    "index0",
                    new NumericValue(i)
                ],
                [
                    "revindex",
                    new NumericValue(iterable.value.length - i)
                ],
                [
                    "revindex0",
                    new NumericValue(iterable.value.length - i - 1)
                ],
                [
                    "first",
                    new BooleanValue(i === 0)
                ],
                [
                    "last",
                    new BooleanValue(i === iterable.value.length - 1)
                ],
                [
                    "length",
                    new NumericValue(iterable.value.length)
                ],
                [
                    "previtem",
                    i > 0 ? iterable.value[i - 1] : new UndefinedValue()
                ],
                [
                    "nextitem",
                    i < iterable.value.length - 1 ? iterable.value[i + 1] : new UndefinedValue()
                ]
            ]);
            scope.setVariable("loop", new ObjectValue(loop));
            const current = iterable.value[i];
            if (node.loopvar.type === "Identifier") {
                scope.setVariable(node.loopvar.value, current);
            } else if (node.loopvar.type === "TupleLiteral") {
                const loopvar = node.loopvar;
                if (current.type !== "ArrayValue") {
                    throw new Error(`Cannot unpack non-iterable type: ${current.type}`);
                }
                const c = current;
                if (loopvar.value.length !== c.value.length) {
                    throw new Error(`Too ${loopvar.value.length > c.value.length ? "few" : "many"} items to unpack`);
                }
                for(let j = 0; j < loopvar.value.length; ++j){
                    if (loopvar.value[j].type !== "Identifier") {
                        throw new Error(`Cannot unpack non-identifier type: ${loopvar.value[j].type}`);
                    }
                    scope.setVariable(loopvar.value[j].value, c.value[j]);
                }
            }
            const evaluated = this.evaluateBlock(node.body, scope);
            result += evaluated.value;
        }
        return new StringValue(result);
    }
    evaluate(statement, environment) {
        if (statement === void 0) return new UndefinedValue();
        switch(statement.type){
            case "Program":
                return this.evalProgram(statement, environment);
            case "Set":
                return this.evaluateSet(statement, environment);
            case "If":
                return this.evaluateIf(statement, environment);
            case "For":
                return this.evaluateFor(statement, environment);
            case "NumericLiteral":
                return new NumericValue(Number(statement.value));
            case "StringLiteral":
                return new StringValue(statement.value);
            case "BooleanLiteral":
                return new BooleanValue(statement.value);
            case "ArrayLiteral":
                return new ArrayValue(statement.value.map((x)=>this.evaluate(x, environment)));
            case "TupleLiteral":
                return new TupleValue(statement.value.map((x)=>this.evaluate(x, environment)));
            case "ObjectLiteral":
                {
                    const mapping = /* @__PURE__ */ new Map();
                    for (const [key, value] of statement.value){
                        const evaluatedKey = this.evaluate(key, environment);
                        if (!(evaluatedKey instanceof StringValue)) {
                            throw new Error(`Object keys must be strings: got ${evaluatedKey.type}`);
                        }
                        mapping.set(evaluatedKey.value, this.evaluate(value, environment));
                    }
                    return new ObjectValue(mapping);
                }
            case "Identifier":
                return this.evaluateIdentifier(statement, environment);
            case "CallExpression":
                return this.evaluateCallExpression(statement, environment);
            case "MemberExpression":
                return this.evaluateMemberExpression(statement, environment);
            case "UnaryExpression":
                return this.evaluateUnaryExpression(statement, environment);
            case "BinaryExpression":
                return this.evaluateBinaryExpression(statement, environment);
            case "FilterExpression":
                return this.evaluateFilterExpression(statement, environment);
            case "TestExpression":
                return this.evaluateTestExpression(statement, environment);
            default:
                throw new SyntaxError(`Unknown node type: ${statement.type}`);
        }
    }
};
function convertToRuntimeValues(input) {
    switch(typeof input){
        case "number":
            return new NumericValue(input);
        case "string":
            return new StringValue(input);
        case "boolean":
            return new BooleanValue(input);
        case "object":
            if (input === null) {
                return new NullValue();
            } else if (Array.isArray(input)) {
                return new ArrayValue(input.map(convertToRuntimeValues));
            } else {
                return new ObjectValue(new Map(Object.entries(input).map(([key, value])=>[
                        key,
                        convertToRuntimeValues(value)
                    ])));
            }
        case "function":
            return new FunctionValue((args, _scope)=>{
                const result = input(...args.map((x)=>x.value)) ?? null;
                return convertToRuntimeValues(result);
            });
        default:
            throw new Error(`Cannot convert to runtime value: ${input}`);
    }
}
// src/index.ts
var Template = class {
    parsed;
    /**
   * @param {string} template The template string
   */ constructor(template){
        const tokens = tokenize(template, {
            lstrip_blocks: true,
            trim_blocks: true
        });
        this.parsed = parse(tokens);
    }
    render(items) {
        const env = new Environment();
        env.set("false", false);
        env.set("true", true);
        env.set("raise_exception", (args)=>{
            throw new Error(args);
        });
        env.set("range", range);
        for (const [key, value] of Object.entries(items)){
            env.set(key, value);
        }
        const interpreter = new Interpreter(env);
        const result = interpreter.run(this.parsed);
        return result.value;
    }
};
;
}),
]);

//# sourceMappingURL=node_modules_9ac399fe._.js.map