{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/jaena/Downloads/toolsapp/app/api/encrypt-pdf/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\"\n\nexport const runtime = \"nodejs\"\n\nexport async function POST(request: Request) {\n  try {\n    // Cargar pdf-encrypt dinámicamente para evitar problemas de resolución\n    const { default: pdfEncrypt } = await import(\"pdf-encrypt\")\n\n    const formData = await request.formData()\n    const file = formData.get(\"file\") as File | null\n    const password = (formData.get(\"password\") as string) || \"\"\n\n    const printing = formData.get(\"printing\") === \"true\"\n    const modifying = formData.get(\"modifying\") === \"true\"\n    const copying = formData.get(\"copying\") === \"true\"\n    const annotating = formData.get(\"annotating\") === \"true\"\n\n    if (!file) {\n      return NextResponse.json({ error: \"No file provided\" }, { status: 400 })\n    }\n\n    if (!password || password.length < 4) {\n      return NextResponse.json({ error: \"Password must be at least 4 characters\" }, { status: 400 })\n    }\n\n    const arrayBuffer = await file.arrayBuffer()\n    const inputBuffer = Buffer.from(arrayBuffer)\n\n    const encryptedBuffer: Buffer = await new Promise((resolve, reject) => {\n      pdfEncrypt(\n        inputBuffer,\n        {\n          userPassword: password,\n          ownerPassword: password + \"_owner\",\n          permissions: {\n            print: printing,\n            modify: modifying,\n            copy: copying,\n            annotate: annotating,\n          },\n        },\n        (err: any, buffer: Buffer) => {\n          if (err) return reject(err)\n          resolve(buffer)\n        }\n      )\n    })\n\n    // Convert Buffer to ArrayBuffer for Response body\n    // Create a clean ArrayBuffer from the Buffer to avoid SharedArrayBuffer unions\n    const out = new Uint8Array(encryptedBuffer.byteLength)\n    out.set(encryptedBuffer)\n    const outBlob = new Blob([out.buffer], { type: 'application/pdf' })\n\n    return new NextResponse(outBlob, {\n      status: 200,\n      headers: {\n        \"Content-Type\": \"application/pdf\",\n        \"Content-Disposition\": `attachment; filename=\"encrypted.pdf\"`,\n      },\n    })\n  } catch (error) {\n    console.error(\"[api/encrypt-pdf] Error:\", error)\n    return NextResponse.json({ error: \"Failed to encrypt PDF\" }, { status: 500 })\n  }\n}"],"names":[],"mappings":";;;;;;AAAA;;AAEO,MAAM,UAAU;AAEhB,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,uEAAuE;QACvE,MAAM,EAAE,SAAS,UAAU,EAAE,GAAG;;;;;QAEhC,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAC1B,MAAM,WAAW,AAAC,SAAS,GAAG,CAAC,eAA0B;QAEzD,MAAM,WAAW,SAAS,GAAG,CAAC,gBAAgB;QAC9C,MAAM,YAAY,SAAS,GAAG,CAAC,iBAAiB;QAChD,MAAM,UAAU,SAAS,GAAG,CAAC,eAAe;QAC5C,MAAM,aAAa,SAAS,GAAG,CAAC,kBAAkB;QAElD,IAAI,CAAC,MAAM;YACT,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAmB,GAAG;gBAAE,QAAQ;YAAI;QACxE;QAEA,IAAI,CAAC,YAAY,SAAS,MAAM,GAAG,GAAG;YACpC,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAyC,GAAG;gBAAE,QAAQ;YAAI;QAC9F;QAEA,MAAM,cAAc,MAAM,KAAK,WAAW;QAC1C,MAAM,cAAc,OAAO,IAAI,CAAC;QAEhC,MAAM,kBAA0B,MAAM,IAAI,QAAQ,CAAC,SAAS;YAC1D,WACE,aACA;gBACE,cAAc;gBACd,eAAe,WAAW;gBAC1B,aAAa;oBACX,OAAO;oBACP,QAAQ;oBACR,MAAM;oBACN,UAAU;gBACZ;YACF,GACA,CAAC,KAAU;gBACT,IAAI,KAAK,OAAO,OAAO;gBACvB,QAAQ;YACV;QAEJ;QAEA,kDAAkD;QAClD,+EAA+E;QAC/E,MAAM,MAAM,IAAI,WAAW,gBAAgB,UAAU;QACrD,IAAI,GAAG,CAAC;QACR,MAAM,UAAU,IAAI,KAAK;YAAC,IAAI,MAAM;SAAC,EAAE;YAAE,MAAM;QAAkB;QAEjE,OAAO,IAAI,gJAAY,CAAC,SAAS;YAC/B,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,uBAAuB,CAAC,oCAAoC,CAAC;YAC/D;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC7E;AACF","debugId":null}}]
}