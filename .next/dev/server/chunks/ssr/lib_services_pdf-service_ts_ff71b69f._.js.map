{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/jaena/Downloads/toolsapp/lib/services/pdf-service.ts"],"sourcesContent":["import { PDFDocument, rgb, StandardFonts } from \"pdf-lib\"\nimport { Document, Packer, Paragraph, TextRun } from \"docx\"\n\n// Dynamic import for PDF.js to avoid SSR issues\nlet pdfjsLib: any = null\n\n// Configure PDF.js worker only on client side\nif (typeof window !== \"undefined\") {\n  import(\"pdfjs-dist\").then((pdfjs) => {\n    pdfjsLib = pdfjs\n    pdfjsLib.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.js\"\n  })\n}\n\nexport interface PDFToWordOptions {\n  file: File\n  preserveFormatting?: boolean\n  includeImages?: boolean\n  includeTables?: boolean\n}\n\nexport interface PDFToImagesOptions {\n  file: File\n  format: \"png\" | \"jpeg\" | \"webp\"\n  quality?: number\n  scale?: number\n}\n\nexport interface CompressPDFOptions {\n  file: File\n  quality?: 'low' | 'medium' | 'high'\n}\n\nexport interface EncryptPDFOptions {\n  file: File\n  password: string\n  permissions?: {\n    printing?: boolean\n    modifying?: boolean\n    copying?: boolean\n    annotating?: boolean\n  }\n}\n\nexport interface MergePDFOptions {\n  files: File[]\n}\n\nexport class PDFService {\n  /**\n   * Extract text from PDF file\n   */\n  static async extractTextFromPDF(file: File): Promise<string[]> {\n    if (typeof window === \"undefined\") {\n      throw new Error(\"PDF text extraction is only available on the client side\")\n    }\n\n    if (!pdfjsLib) {\n      pdfjsLib = await import(\"pdfjs-dist\")\n      pdfjsLib.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.js\"\n    }\n\n    try {\n      const arrayBuffer = await file.arrayBuffer()\n      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise\n      const textPages: string[] = []\n\n      for (let i = 1; i <= pdf.numPages; i++) {\n        const page = await pdf.getPage(i)\n        const textContent = await page.getTextContent()\n        \n        let pageText = \"\"\n        textContent.items.forEach((item: any) => {\n          if (item.str) {\n            pageText += item.str + \" \"\n          }\n        })\n        \n        textPages.push(pageText.trim())\n      }\n\n      return textPages\n    } catch (error) {\n      console.error('Error extracting text from PDF:', error)\n      throw new Error('Failed to extract text from PDF')\n    }\n  }\n\n  /**\n   * Extract images from PDF\n   */\n  static async extractImagesFromPDF(file: File): Promise<any[]> {\n    if (!pdfjsLib) {\n      throw new Error('PDF.js not loaded')\n    }\n\n    try {\n      const arrayBuffer = await file.arrayBuffer()\n      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise\n      const images: any[] = []\n\n      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {\n        const page = await pdf.getPage(pageNum)\n        const operatorList = await page.getOperatorList()\n        \n        // Look for image operations in the PDF\n        for (let i = 0; i < operatorList.fnArray.length; i++) {\n          if (operatorList.fnArray[i] === pdfjsLib.OPS.paintImageXObject) {\n            images.push({\n              pageIndex: pageNum - 1,\n              imageIndex: i,\n              type: 'image'\n            })\n          }\n        }\n      }\n\n      return images\n    } catch (error) {\n      console.error('Error extracting images from PDF:', error)\n      return []\n    }\n  }\n\n  /**\n   * Convert PDF to Word document\n   */\n  static async convertToWord(options: PDFToWordOptions): Promise<Blob> {\n    const { file, preserveFormatting = true, includeImages = true, includeTables = false } = options\n    \n    try {\n      // Extract text from PDF\n      const textPages = await this.extractTextFromPDF(file)\n      \n      // Extract images if requested\n      let imageElements: any[] = []\n      if (includeImages) {\n        try {\n          imageElements = await this.extractImagesFromPDF(file)\n        } catch (error) {\n          console.warn('Could not extract images from PDF:', error)\n        }\n      }\n      \n      // Create Word document\n      const doc = new Document({\n        sections: [{\n          properties: {},\n          children: [\n            new Paragraph({\n              children: [\n                new TextRun({\n                  text: `Converted from: ${file.name}`,\n                  bold: true,\n                  size: 24,\n                }),\n              ],\n            }),\n            new Paragraph({ text: \"\" }), // Empty line\n            ...textPages.flatMap((pageText, index) => {\n              const pageElements = [\n                new Paragraph({\n                  children: [\n                    new TextRun({\n                      text: `Page ${index + 1}`,\n                      bold: true,\n                      size: 20,\n                    }),\n                  ],\n                }),\n                new Paragraph({ text: \"\" }), // Empty line\n              ]\n\n              // Add text content\n              if (pageText.trim()) {\n                pageElements.push(\n                  ...this.groupSentencesIntoParagraphs(pageText.split(/[.!?]+/))\n                    .map(paragraph => new Paragraph({\n                      children: [\n                        new TextRun({\n                          text: paragraph.trim(),\n                          size: 20,\n                        }),\n                      ],\n                    }))\n                )\n              } else {\n                // If no text, indicate it's an image-only page\n                pageElements.push(\n                  new Paragraph({\n                    children: [\n                      new TextRun({\n                        text: \"[Esta página contiene principalmente imágenes]\",\n                        italics: true,\n                        size: 18,\n                      }),\n                    ],\n                  })\n                )\n              }\n\n              // Add images for this page if available\n              const pageImages = imageElements.filter(img => img.pageIndex === index)\n              if (pageImages.length > 0) {\n                pageElements.push(\n                  new Paragraph({\n                    children: [\n                      new TextRun({\n                        text: `[${pageImages.length} imagen(es) encontrada(s) en esta página]`,\n                        italics: true,\n                        size: 16,\n                      }),\n                    ],\n                  })\n                )\n              }\n\n              pageElements.push(new Paragraph({ text: \"\" })) // Empty line between pages\n              return pageElements\n            })\n          ],\n        }],\n      })\n\n      // Generate Word document\n      const buffer = await Packer.toBuffer(doc)\n      return new Blob([new Uint8Array(buffer)], { \n        type: \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" \n      })\n    } catch (error) {\n      console.error('Error converting PDF to Word:', error)\n      throw new Error('Failed to convert PDF to Word')\n    }\n  }\n\n  /**\n   * Convert PDF to images\n   */\n  static async convertToImages(options: PDFToImagesOptions): Promise<Blob[]> {\n    if (typeof window === \"undefined\") {\n      throw new Error(\"PDF to images conversion is only available on the client side\")\n    }\n\n    if (!pdfjsLib) {\n      pdfjsLib = await import(\"pdfjs-dist\")\n      pdfjsLib.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.js\"\n    }\n\n    const { file, format, quality = 0.92, scale = 2.0 } = options\n    \n    try {\n      const arrayBuffer = await file.arrayBuffer()\n      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise\n      const images: Blob[] = []\n\n      for (let i = 1; i <= pdf.numPages; i++) {\n        const page = await pdf.getPage(i)\n        const viewport = page.getViewport({ scale })\n        \n        const canvas = document.createElement('canvas')\n        const context = canvas.getContext('2d')!\n        canvas.height = viewport.height\n        canvas.width = viewport.width\n\n        await page.render({\n          canvasContext: context,\n          viewport: viewport\n        }).promise\n\n        const blob = await new Promise<Blob>((resolve) => {\n          canvas.toBlob((blob) => {\n            resolve(blob!)\n          }, `image/${format}`, quality)\n        })\n\n        images.push(blob)\n      }\n\n      return images\n    } catch (error) {\n      console.error('Error converting PDF to images:', error)\n      throw new Error('Failed to convert PDF to images')\n    }\n  }\n\n  /**\n   * Compress PDF file\n   */\n  static async compress(options: CompressPDFOptions): Promise<Blob> {\n    const { file, quality = 'medium' } = options\n    \n    try {\n      const arrayBuffer = await file.arrayBuffer()\n      const pdfDoc = await PDFDocument.load(arrayBuffer)\n\n      // Compression settings based on quality\n      const compressionOptions = {\n        low: { useObjectStreams: false, addDefaultPage: false },\n        medium: { useObjectStreams: true, addDefaultPage: false },\n        high: { useObjectStreams: true, addDefaultPage: false, compress: true }\n      }\n\n      const pdfBytes = await pdfDoc.save(compressionOptions[quality])\n      return new Blob([new Uint8Array(pdfBytes)], { type: \"application/pdf\" })\n    } catch (error) {\n      console.error('Error compressing PDF:', error)\n      throw new Error('Failed to compress PDF')\n    }\n  }\n\n  /**\n   * Encrypt PDF file\n   */\n  static async encrypt(options: EncryptPDFOptions): Promise<Blob> {\n    const { file, password, permissions = {} } = options\n    \n    try {\n      // Import EncryptionService dynamically to avoid circular dependencies\n      const { EncryptionService } = await import('./encryption-service')\n      \n      // Use the real encryption service\n      const result = await EncryptionService.encryptPDF(file, {\n        password,\n        algorithm: 'PDF-Standard',\n        permissions\n      })\n\n      return result.blob\n    } catch (error) {\n      console.error('Error encrypting PDF:', error)\n      throw new Error('Failed to encrypt PDF')\n    }\n  }\n\n  /**\n   * Merge multiple PDF files\n   */\n  static async merge(options: MergePDFOptions): Promise<Blob> {\n    const { files } = options\n    \n    try {\n      const mergedPdf = await PDFDocument.create()\n\n      for (const file of files) {\n        const arrayBuffer = await file.arrayBuffer()\n        const pdf = await PDFDocument.load(arrayBuffer)\n        const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices())\n        copiedPages.forEach((page) => mergedPdf.addPage(page))\n      }\n\n      const pdfBytes = await mergedPdf.save()\n      return new Blob([new Uint8Array(pdfBytes)], { type: \"application/pdf\" })\n    } catch (error) {\n      console.error('Error merging PDFs:', error)\n      throw new Error('Failed to merge PDFs')\n    }\n  }\n\n  /**\n   * Group sentences into paragraphs for better Word formatting\n   */\n  private static groupSentencesIntoParagraphs(sentences: string[]): string[] {\n    const paragraphs: string[] = []\n    let currentParagraph = \"\"\n    \n    sentences.forEach((sentence) => {\n      const trimmedSentence = sentence.trim()\n      if (trimmedSentence) {\n        if (currentParagraph.length + trimmedSentence.length > 500) {\n          if (currentParagraph) {\n            paragraphs.push(currentParagraph.trim())\n          }\n          currentParagraph = trimmedSentence + \". \"\n        } else {\n          currentParagraph += trimmedSentence + \". \"\n        }\n      }\n    })\n    \n    if (currentParagraph.trim()) {\n      paragraphs.push(currentParagraph.trim())\n    }\n    \n    return paragraphs\n  }\n\n  /**\n   * Validate if file is a valid PDF\n   */\n  static async validatePDF(file: File): Promise<boolean> {\n    try {\n      const arrayBuffer = await file.arrayBuffer()\n      await PDFDocument.load(arrayBuffer)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Get PDF metadata\n   */\n  static async getPDFInfo(file: File): Promise<{\n    pageCount: number\n    title?: string\n    author?: string\n    subject?: string\n    creator?: string\n  }> {\n    if (typeof window === \"undefined\") {\n      throw new Error(\"PDF info extraction is only available on the client side\")\n    }\n\n    if (!pdfjsLib) {\n      pdfjsLib = await import(\"pdfjs-dist\")\n      pdfjsLib.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.js\"\n    }\n\n    try {\n      const arrayBuffer = await file.arrayBuffer()\n      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise\n      const metadata = await pdf.getMetadata()\n      \n      return {\n        pageCount: pdf.numPages,\n        title: metadata.info?.Title,\n        author: metadata.info?.Author,\n        subject: metadata.info?.Subject,\n        creator: metadata.info?.Creator,\n      }\n    } catch (error) {\n      console.error('Error getting PDF info:', error)\n      throw new Error('Failed to get PDF information')\n    }\n  }\n\n  /**\n   * Wrap text for better formatting\n   */\n  private static wrapText(text: string, maxLength: number): string[] {\n    const words = text.split(\" \")\n    const lines: string[] = []\n    let currentLine = \"\"\n\n    words.forEach((word) => {\n      if (currentLine.length + word.length + 1 <= maxLength) {\n        currentLine += (currentLine ? \" \" : \"\") + word\n      } else {\n        if (currentLine) lines.push(currentLine)\n        currentLine = word\n      }\n    })\n\n    if (currentLine) lines.push(currentLine)\n    return lines\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}